<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>../HindleyMilner.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE LambdaCase                 #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE OverloadedLists            #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE OverloadedStrings          #-}</span>
<a name="line-5"></a>
<a name="line-6"></a>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-comment'>-- | This module is an extensively documented walkthrough for typechecking a</span>
<a name="line-9"></a><span class='hs-comment'>-- basic functional language using the Hindley-Damas-Milner algorithm.</span>
<a name="line-10"></a><span class='hs-comment'>--</span>
<a name="line-11"></a><span class='hs-comment'>-- It can be used in three different forms:</span>
<a name="line-12"></a><span class='hs-comment'>--</span>
<a name="line-13"></a><span class='hs-comment'>-- - The source is written in literate programming style, so you can almost</span>
<a name="line-14"></a><span class='hs-comment'>--   read it from top to bottom, minus some few references to later.</span>
<a name="line-15"></a><span class='hs-comment'>-- - Runnable in GHCi.</span>
<a name="line-16"></a><span class='hs-comment'>-- - The Haddock output yields a nice overview over the definitions given.</span>
<a name="line-17"></a><span class='hs-comment'>--   It's not as good of a read as the source since many of the important</span>
<a name="line-18"></a><span class='hs-comment'>--   inter-code comments are not visible.</span>
<a name="line-19"></a>
<a name="line-20"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Main</span> <span class='hs-keyword'>where</span>
<a name="line-21"></a>
<a name="line-22"></a><span class='hs-keyword'>import</span>           <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Identity</span>
<a name="line-23"></a><span class='hs-keyword'>import</span>           <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Trans</span>
<a name="line-24"></a><span class='hs-keyword'>import</span>           <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Trans</span><span class='hs-varop'>.</span><span class='hs-conid'>Except</span>
<a name="line-25"></a><span class='hs-keyword'>import</span>           <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Trans</span><span class='hs-varop'>.</span><span class='hs-conid'>State</span>
<a name="line-26"></a><span class='hs-keyword'>import</span>           <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span>                   <span class='hs-layout'>(</span><span class='hs-conid'>Map</span><span class='hs-layout'>)</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Map</span>                   <span class='hs-keyword'>as</span> <span class='hs-conid'>M</span>
<a name="line-28"></a><span class='hs-keyword'>import</span>           <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Monoid</span>
<a name="line-29"></a><span class='hs-keyword'>import</span>           <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span>                   <span class='hs-layout'>(</span><span class='hs-conid'>Set</span><span class='hs-layout'>)</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span>                   <span class='hs-keyword'>as</span> <span class='hs-conid'>S</span>
<a name="line-31"></a><span class='hs-keyword'>import</span>           <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>String</span>
<a name="line-32"></a><span class='hs-keyword'>import</span>           <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span>                  <span class='hs-layout'>(</span><span class='hs-conid'>Text</span><span class='hs-layout'>)</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span>                  <span class='hs-keyword'>as</span> <span class='hs-conid'>T</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span><span class='hs-varop'>.</span><span class='hs-conid'>IO</span>               <span class='hs-keyword'>as</span> <span class='hs-conid'>T</span>
<a name="line-35"></a>
<a name="line-36"></a>
<a name="line-37"></a>
<a name="line-38"></a>
<a name="line-39"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-40"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-41"></a><span class='hs-comment'>-- * Preliminaries</span>
<a name="line-42"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-43"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-44"></a>
<a name="line-45"></a>
<a name="line-46"></a>
<a name="line-47"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-48"></a><span class='hs-comment'>-- ** Prettyprinting</span>
<a name="line-49"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-50"></a>
<a name="line-51"></a>
<a name="line-52"></a>
<a name="line-53"></a><a name="Pretty"></a><span class='hs-comment'>-- | A prettyprinter class. Similar to 'Show', but with a focus on having</span>
<a name="line-54"></a><a name="Pretty"></a><span class='hs-comment'>-- human-readable output as opposed to being valid Haskell.</span>
<a name="line-55"></a><a name="Pretty"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Pretty</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<a name="line-56"></a>    <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Text</span>
<a name="line-57"></a>
<a name="line-58"></a>
<a name="line-59"></a>
<a name="line-60"></a>
<a name="line-61"></a>
<a name="line-62"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-63"></a><span class='hs-comment'>-- ** Names</span>
<a name="line-64"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-65"></a>
<a name="line-66"></a>
<a name="line-67"></a>
<a name="line-68"></a><a name="Name"></a><span class='hs-comment'>-- | A 'name' is an identifier in the language we're going to typecheck.</span>
<a name="line-69"></a><a name="Name"></a><span class='hs-comment'>-- Variables on both the term and type level have 'Name's, for example.</span>
<a name="line-70"></a><a name="Name"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Name</span> <span class='hs-conid'>Text</span>
<a name="line-71"></a>    <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span><span class='hs-layout'>)</span>
<a name="line-72"></a>
<a name="line-73"></a><a name="instance%20IsString%20Name"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>IsString</span> <span class='hs-conid'>Name</span> <span class='hs-keyword'>where</span>
<a name="line-74"></a>    <span class='hs-varid'>fromString</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Name</span> <span class='hs-varop'>.</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>pack</span>
<a name="line-75"></a>
<a name="line-76"></a><a name="instance%20Pretty%20Name"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Pretty</span> <span class='hs-conid'>Name</span> <span class='hs-keyword'>where</span>
<a name="line-77"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Name</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-78"></a>
<a name="line-79"></a>
<a name="line-80"></a>
<a name="line-81"></a>
<a name="line-82"></a>
<a name="line-83"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-84"></a><span class='hs-comment'>-- ** Monotypes</span>
<a name="line-85"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-86"></a>
<a name="line-87"></a>
<a name="line-88"></a>
<a name="line-89"></a><a name="MType"></a><span class='hs-comment'>-- | A monotype is an unquantified/unparametric type. Monotypes are the inner</span>
<a name="line-90"></a><a name="MType"></a><span class='hs-comment'>-- building blocks of all types. Examples of monotypes are @Int@, @a@, @a -&gt; b@.</span>
<a name="line-91"></a><a name="MType"></a><span class='hs-comment'>--</span>
<a name="line-92"></a><a name="MType"></a><span class='hs-comment'>-- In formal notation, 'MType's are often called τ (tau) types.</span>
<a name="line-93"></a><a name="MType"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>MType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TVar</span> <span class='hs-conid'>Name</span>           <span class='hs-comment'>-- ^ @a@</span>
<a name="line-94"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TFun</span> <span class='hs-conid'>MType</span> <span class='hs-conid'>MType</span>    <span class='hs-comment'>-- ^ @a -&gt; b@</span>
<a name="line-95"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TConst</span> <span class='hs-conid'>Name</span>         <span class='hs-comment'>-- ^ @Int@, @()@, …</span>
<a name="line-96"></a>
<a name="line-97"></a>           <span class='hs-comment'>-- Since we can't declare our own types in our simple type system</span>
<a name="line-98"></a>           <span class='hs-comment'>-- here, we'll hard-code certain basic ones so we can typecheck some</span>
<a name="line-99"></a>           <span class='hs-comment'>-- familar functions that use them later.</span>
<a name="line-100"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TList</span> <span class='hs-conid'>MType</span>         <span class='hs-comment'>-- ^ @[a]@</span>
<a name="line-101"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TEither</span> <span class='hs-conid'>MType</span> <span class='hs-conid'>MType</span> <span class='hs-comment'>-- ^ @Either a b@</span>
<a name="line-102"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TTuple</span> <span class='hs-conid'>MType</span> <span class='hs-conid'>MType</span>  <span class='hs-comment'>-- ^ @(a,b)@</span>
<a name="line-103"></a>
<a name="line-104"></a><a name="instance%20Pretty%20MType"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Pretty</span> <span class='hs-conid'>MType</span> <span class='hs-keyword'>where</span>
<a name="line-105"></a>    <span class='hs-comment'>-- ^ @</span>
<a name="line-106"></a>    <span class='hs-comment'>-- TFun (TVar "a") (TVar "b")</span>
<a name="line-107"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; a → b</span>
<a name="line-108"></a>    <span class='hs-comment'>-- @</span>
<a name="line-109"></a>
<a name="line-110"></a>    <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>False</span>
<a name="line-111"></a>      <span class='hs-keyword'>where</span>
<a name="line-112"></a>        <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>TVar</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span>
<a name="line-113"></a>        <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>TList</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-str'>"["</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>a</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>"]"</span>
<a name="line-114"></a>        <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>TEither</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Either "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>l</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>" "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>r</span>
<a name="line-115"></a>        <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>TTuple</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-str'>"("</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>a</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>", "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>")"</span>
<a name="line-116"></a>        <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>TConst</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span>
<a name="line-117"></a>        <span class='hs-varid'>go</span> <span class='hs-varid'>parenthesize</span> <span class='hs-layout'>(</span><span class='hs-conid'>TFun</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-118"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>parenthesize</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"("</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>lhs</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>" → "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>rhs</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>")"</span>
<a name="line-119"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span>        <span class='hs-varid'>lhs</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>" → "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>rhs</span>
<a name="line-120"></a>            <span class='hs-keyword'>where</span> <span class='hs-varid'>lhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>True</span> <span class='hs-varid'>a</span>
<a name="line-121"></a>                  <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>False</span> <span class='hs-varid'>b</span>
<a name="line-122"></a>
<a name="line-123"></a><a name="instance%20IsString%20MType"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>IsString</span> <span class='hs-conid'>MType</span> <span class='hs-keyword'>where</span>
<a name="line-124"></a>    <span class='hs-comment'>-- ^ 'String' → 'TVar'</span>
<a name="line-125"></a>    <span class='hs-varid'>fromString</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TVar</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fromString</span>
<a name="line-126"></a>
<a name="line-127"></a>
<a name="line-128"></a>
<a name="line-129"></a><a name="freeMType"></a><span class='hs-comment'>-- | The free variables of an 'MType'. This is simply the collection of all the</span>
<a name="line-130"></a><span class='hs-comment'>-- individual type variables occurring inside of it.</span>
<a name="line-131"></a><span class='hs-comment'>--</span>
<a name="line-132"></a><span class='hs-comment'>-- __Example:__ The free variables of @a -&gt; b@ are @a@ and @b@.</span>
<a name="line-133"></a><span class='hs-definition'>freeMType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-conid'>Name</span>
<a name="line-134"></a><span class='hs-definition'>freeMType</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-135"></a>    <span class='hs-conid'>TVar</span> <span class='hs-varid'>a</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-136"></a>    <span class='hs-conid'>TFun</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>freeMType</span> <span class='hs-varid'>f</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>freeMType</span> <span class='hs-varid'>x</span>
<a name="line-137"></a>    <span class='hs-conid'>TList</span> <span class='hs-varid'>a</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>freeMType</span> <span class='hs-varid'>a</span>
<a name="line-138"></a>    <span class='hs-conid'>TEither</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>freeMType</span> <span class='hs-varid'>l</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>freeMType</span> <span class='hs-varid'>r</span>
<a name="line-139"></a>    <span class='hs-conid'>TTuple</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>freeMType</span> <span class='hs-varid'>a</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>freeMType</span> <span class='hs-varid'>b</span>
<a name="line-140"></a>    <span class='hs-conid'>TConst</span> <span class='hs-keyword'>_</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
<a name="line-141"></a>
<a name="line-142"></a>
<a name="line-143"></a>
<a name="line-144"></a>
<a name="line-145"></a><a name="substMType"></a><span class='hs-comment'>-- | Apply a substitution to all known variables contained in an 'MType'.</span>
<a name="line-146"></a><span class='hs-comment'>-- Variables not mentioned are left unchanged.</span>
<a name="line-147"></a><span class='hs-comment'>--</span>
<a name="line-148"></a><span class='hs-comment'>-- This operation will not change the 'MType' constructors that may be contained</span>
<a name="line-149"></a><span class='hs-comment'>-- inside the 'MType' recursively, it only acts on type variables.</span>
<a name="line-150"></a><span class='hs-definition'>substMType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Subst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MType</span>
<a name="line-151"></a><span class='hs-definition'>substMType</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-152"></a>    <span class='hs-conid'>TVar</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>let</span> <span class='hs-conid'>Subst</span> <span class='hs-varid'>s'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>s</span>
<a name="line-153"></a>              <span class='hs-keyword'>in</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>findWithDefault</span> <span class='hs-layout'>(</span><span class='hs-conid'>TVar</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span> <span class='hs-varid'>s'</span>
<a name="line-154"></a>    <span class='hs-conid'>TFun</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TFun</span> <span class='hs-layout'>(</span><span class='hs-varid'>rec</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>rec</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-155"></a>    <span class='hs-conid'>TList</span> <span class='hs-varid'>a</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TList</span> <span class='hs-layout'>(</span><span class='hs-varid'>rec</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-156"></a>    <span class='hs-conid'>TEither</span> <span class='hs-varid'>l</span> <span class='hs-varid'>r</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TEither</span> <span class='hs-layout'>(</span><span class='hs-varid'>rec</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>rec</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-157"></a>    <span class='hs-conid'>TTuple</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TTuple</span> <span class='hs-layout'>(</span><span class='hs-varid'>rec</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>rec</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-158"></a>    <span class='hs-varid'>c</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>TConst</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span>
<a name="line-159"></a>  <span class='hs-keyword'>where</span>
<a name="line-160"></a>    <span class='hs-varid'>rec</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substMType</span> <span class='hs-varid'>s</span>
<a name="line-161"></a>
<a name="line-162"></a>
<a name="line-163"></a>
<a name="line-164"></a>
<a name="line-165"></a>
<a name="line-166"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-167"></a><span class='hs-comment'>-- ** Polytypes</span>
<a name="line-168"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-169"></a>
<a name="line-170"></a>
<a name="line-171"></a><a name="PType"></a><span class='hs-comment'>-- | A polytype is a monotype universally quantified over a number of type</span>
<a name="line-172"></a><a name="PType"></a><span class='hs-comment'>-- variables. In Haskell, all definitions have polytypes, but since the @forall@</span>
<a name="line-173"></a><a name="PType"></a><span class='hs-comment'>-- is implicit they look a bit like monotypes, maybe confusingly so. For</span>
<a name="line-174"></a><a name="PType"></a><span class='hs-comment'>-- example, the type of "1 :: Int" is actually "forall &lt;nothing&gt;. Int", and</span>
<a name="line-175"></a><a name="PType"></a><span class='hs-comment'>-- the type of "id" is "forall a. a -&gt; a", although GHC displays it as</span>
<a name="line-176"></a><a name="PType"></a><span class='hs-comment'>-- "a -&gt; a".</span>
<a name="line-177"></a><a name="PType"></a><span class='hs-comment'>--</span>
<a name="line-178"></a><a name="PType"></a><span class='hs-comment'>-- A polytype claims to work "for all imaginable type parameters", very similar</span>
<a name="line-179"></a><a name="PType"></a><span class='hs-comment'>-- to how a lambda claims to work "for all imaginable value parameters". We can</span>
<a name="line-180"></a><a name="PType"></a><span class='hs-comment'>-- insert a value into a lambda's parameter to evaluate it to a new value, and</span>
<a name="line-181"></a><a name="PType"></a><span class='hs-comment'>-- similarly we'll later insert types into a polytype's quantified variables</span>
<a name="line-182"></a><a name="PType"></a><span class='hs-comment'>-- to gain new types.</span>
<a name="line-183"></a><a name="PType"></a><span class='hs-comment'>--</span>
<a name="line-184"></a><a name="PType"></a><span class='hs-comment'>-- __Example:__ in a definition @id :: forall a. a -&gt; a@, the @a@ after the</span>
<a name="line-185"></a><a name="PType"></a><span class='hs-comment'>-- ∀ ("forall") is the collection of type variables, and @a -&gt; a@ is the</span>
<a name="line-186"></a><a name="PType"></a><span class='hs-comment'>-- 'MType' quantified over. When we have such an @id@, we also have its</span>
<a name="line-187"></a><a name="PType"></a><span class='hs-comment'>-- specialized version @Int -&gt; Int@ available. This process will be the</span>
<a name="line-188"></a><a name="PType"></a><span class='hs-comment'>-- topic of the type inference/unification algorithms.</span>
<a name="line-189"></a><a name="PType"></a><span class='hs-comment'>--</span>
<a name="line-190"></a><a name="PType"></a><span class='hs-comment'>-- In formal notation, 'PType's are often called σ (sigma) types.</span>
<a name="line-191"></a><a name="PType"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>PType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Forall</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Name</span><span class='hs-layout'>)</span> <span class='hs-conid'>MType</span>
<a name="line-192"></a>
<a name="line-193"></a><a name="instance%20Pretty%20PType"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Pretty</span> <span class='hs-conid'>PType</span> <span class='hs-keyword'>where</span>
<a name="line-194"></a>    <span class='hs-comment'>-- ^ @</span>
<a name="line-195"></a>    <span class='hs-comment'>-- Forall ["a"] (TFun "a" "a")</span>
<a name="line-196"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; ∀a. a → a</span>
<a name="line-197"></a>    <span class='hs-comment'>-- @</span>
<a name="line-198"></a>
<a name="line-199"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Forall</span> <span class='hs-varid'>qs</span> <span class='hs-varid'>mType</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"∀"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>universals</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>". "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mType</span>
<a name="line-200"></a>      <span class='hs-keyword'>where</span>
<a name="line-201"></a>        <span class='hs-varid'>universals</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>intercalate</span> <span class='hs-str'>" "</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>toList</span> <span class='hs-varid'>qs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-202"></a>
<a name="line-203"></a>
<a name="line-204"></a>
<a name="line-205"></a><a name="freePType"></a><span class='hs-comment'>-- | The free variables of a 'PType' are the free variables of the contained</span>
<a name="line-206"></a><span class='hs-comment'>-- 'MType', except those universally quantified.</span>
<a name="line-207"></a><span class='hs-comment'>--</span>
<a name="line-208"></a><span class='hs-comment'>-- __Example:__ @foo :: forall a. a -&gt; b -&gt; a@ would be a 'PType' in which</span>
<a name="line-209"></a><span class='hs-comment'>-- @b@ is a free type variable, while @a@ is bound (via the @forall@).</span>
<a name="line-210"></a><span class='hs-definition'>freePType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-conid'>Name</span>
<a name="line-211"></a><span class='hs-definition'>freePType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Forall</span> <span class='hs-varid'>qs</span> <span class='hs-varid'>mType</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>freeMType</span> <span class='hs-varid'>mType</span> <span class='hs-varop'>`</span><span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>difference</span><span class='hs-varop'>`</span> <span class='hs-varid'>qs</span>
<a name="line-212"></a>
<a name="line-213"></a>
<a name="line-214"></a>
<a name="line-215"></a><a name="substPType"></a><span class='hs-comment'>-- | Apply a substitution to a 'PType', replacing all known variables in the</span>
<a name="line-216"></a><span class='hs-comment'>-- contained 'MType' except the ones universally quantified.</span>
<a name="line-217"></a><span class='hs-comment'>--</span>
<a name="line-218"></a><span class='hs-comment'>-- Invariant: the quantified variables are not changed by the operation.</span>
<a name="line-219"></a><span class='hs-definition'>substPType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Subst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PType</span>
<a name="line-220"></a><span class='hs-definition'>substPType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Subst</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Forall</span> <span class='hs-varid'>qs</span> <span class='hs-varid'>mType</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-221"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>qs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>fromSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span> <span class='hs-varid'>qs</span>
<a name="line-222"></a>        <span class='hs-varid'>subst'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst</span> <span class='hs-varop'>`</span><span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>difference</span><span class='hs-varop'>`</span> <span class='hs-varid'>qs'</span><span class='hs-layout'>)</span>
<a name="line-223"></a>    <span class='hs-keyword'>in</span> <span class='hs-conid'>Forall</span> <span class='hs-varid'>qs</span> <span class='hs-layout'>(</span><span class='hs-varid'>substMType</span> <span class='hs-varid'>subst'</span> <span class='hs-varid'>mType</span><span class='hs-layout'>)</span>
<a name="line-224"></a>
<a name="line-225"></a>
<a name="line-226"></a>
<a name="line-227"></a>
<a name="line-228"></a>
<a name="line-229"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-230"></a><span class='hs-comment'>-- ** The environment</span>
<a name="line-231"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-232"></a>
<a name="line-233"></a>
<a name="line-234"></a>
<a name="line-235"></a><a name="Env"></a><span class='hs-comment'>-- | The environment consists of all the values available in scope, and their</span>
<a name="line-236"></a><a name="Env"></a><span class='hs-comment'>-- associated polytypes.</span>
<a name="line-237"></a><a name="Env"></a><span class='hs-comment'>--</span>
<a name="line-238"></a><a name="Env"></a><span class='hs-comment'>-- Conceptually, the environment also contains all the things you can form by</span>
<a name="line-239"></a><a name="Env"></a><span class='hs-comment'>-- combining its elements, but this behaviour is modeled by the inference rules</span>
<a name="line-240"></a><a name="Env"></a><span class='hs-comment'>-- and not by the environment itself. This is a good thing, since the</span>
<a name="line-241"></a><a name="Env"></a><span class='hs-comment'>-- environment makes infinitely many things available to us: when we have</span>
<a name="line-242"></a><a name="Env"></a><span class='hs-comment'>-- @z@, then we also have @\y -&gt; z@ and @\x y -&gt; z@ and so on available to us.</span>
<a name="line-243"></a><a name="Env"></a><span class='hs-comment'>--</span>
<a name="line-244"></a><a name="Env"></a><span class='hs-comment'>-- In Haskell terms, the environment consists of all the things you currently</span>
<a name="line-245"></a><a name="Env"></a><span class='hs-comment'>-- have available. So if you import the Prelude, your environment consists of</span>
<a name="line-246"></a><a name="Env"></a><span class='hs-comment'>--</span>
<a name="line-247"></a><a name="Env"></a><span class='hs-comment'>-- @</span>
<a name="line-248"></a><a name="Env"></a><span class='hs-comment'>-- id        →  ∀a. a→a</span>
<a name="line-249"></a><a name="Env"></a><span class='hs-comment'>-- map       →  ∀a b. (a→b) → [a] → [b]</span>
<a name="line-250"></a><a name="Env"></a><span class='hs-comment'>-- putStrLn  →  ∀∅. String → IO ()</span>
<a name="line-251"></a><a name="Env"></a><span class='hs-comment'>-- …</span>
<a name="line-252"></a><a name="Env"></a><span class='hs-comment'>-- @</span>
<a name="line-253"></a><a name="Env"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Map</span> <span class='hs-conid'>Name</span> <span class='hs-conid'>PType</span><span class='hs-layout'>)</span>
<a name="line-254"></a>
<a name="line-255"></a><a name="instance%20Pretty%20Env"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Pretty</span> <span class='hs-conid'>Env</span> <span class='hs-keyword'>where</span>
<a name="line-256"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Env</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Γ = \n"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>intercalate</span> <span class='hs-str'>"\n"</span> <span class='hs-varid'>pprBindings</span>
<a name="line-257"></a>      <span class='hs-keyword'>where</span>
<a name="line-258"></a>        <span class='hs-varid'>bindings</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>assocs</span> <span class='hs-varid'>env</span>
<a name="line-259"></a>        <span class='hs-varid'>pprBinding</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>pType</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"  "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>" ≡ "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pType</span>
<a name="line-260"></a>        <span class='hs-varid'>pprBindings</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>pprBinding</span> <span class='hs-varid'>bindings</span>
<a name="line-261"></a>
<a name="line-262"></a>
<a name="line-263"></a>
<a name="line-264"></a><a name="freeEnv"></a><span class='hs-comment'>-- | The free variables of an 'Env'ironment are all the free variables of the</span>
<a name="line-265"></a><span class='hs-comment'>-- 'PType's it contains.</span>
<a name="line-266"></a><span class='hs-definition'>freeEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set</span> <span class='hs-conid'>Name</span>
<a name="line-267"></a><span class='hs-definition'>freeEnv</span> <span class='hs-layout'>(</span><span class='hs-conid'>Env</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>allPTypes</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>elems</span> <span class='hs-varid'>env</span>
<a name="line-268"></a>                    <span class='hs-keyword'>in</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>unions</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>freePType</span> <span class='hs-varid'>allPTypes</span><span class='hs-layout'>)</span>
<a name="line-269"></a>
<a name="line-270"></a>
<a name="line-271"></a>
<a name="line-272"></a><a name="substEnv"></a><span class='hs-comment'>-- | Performing a 'Subst'itution in an 'Env'ironment means performing that</span>
<a name="line-273"></a><span class='hs-comment'>-- substituion on all the contained 'PType's.</span>
<a name="line-274"></a><span class='hs-definition'>substEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Subst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Env</span>
<a name="line-275"></a><span class='hs-definition'>substEnv</span> <span class='hs-varid'>s</span> <span class='hs-layout'>(</span><span class='hs-conid'>Env</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Env</span> <span class='hs-layout'>(</span><span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>substPType</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-276"></a>
<a name="line-277"></a>
<a name="line-278"></a>
<a name="line-279"></a>
<a name="line-280"></a>
<a name="line-281"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-282"></a><span class='hs-comment'>-- ** Substitutions</span>
<a name="line-283"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-284"></a>
<a name="line-285"></a>
<a name="line-286"></a>
<a name="line-287"></a><a name="Subst"></a><span class='hs-comment'>-- | A substitution is a mapping from type variables to 'MType's. Applying a</span>
<a name="line-288"></a><a name="Subst"></a><span class='hs-comment'>-- substitution means applying those replacements.</span>
<a name="line-289"></a><a name="Subst"></a><span class='hs-comment'>--</span>
<a name="line-290"></a><a name="Subst"></a><span class='hs-comment'>-- If you want to unify @Int -&gt; Int@ with @a -&gt; a@, after inferring that</span>
<a name="line-291"></a><a name="Subst"></a><span class='hs-comment'>-- @a@ should be @Int@, that substituion has to be performed on the latter</span>
<a name="line-292"></a><a name="Subst"></a><span class='hs-comment'>-- value to get rid of all the @a@s.</span>
<a name="line-293"></a><a name="Subst"></a><span class='hs-comment'>--</span>
<a name="line-294"></a><a name="Subst"></a><span class='hs-comment'>-- A maybe more intuitive way that will come in handy for 'compose' is to view</span>
<a name="line-295"></a><a name="Subst"></a><span class='hs-comment'>-- a 'Subst'itution as a chain of</span>
<a name="line-296"></a><a name="Subst"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>Subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Map</span> <span class='hs-conid'>Name</span> <span class='hs-conid'>MType</span><span class='hs-layout'>)</span>
<a name="line-297"></a>
<a name="line-298"></a>
<a name="line-299"></a>
<a name="line-300"></a><a name="instance%20Pretty%20Subst"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Pretty</span> <span class='hs-conid'>Subst</span> <span class='hs-keyword'>where</span>
<a name="line-301"></a>    <span class='hs-comment'>-- ^ a ⇒ b, c ⇒ d → e</span>
<a name="line-302"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Subst</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>intercalate</span> <span class='hs-str'>", "</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>k</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>" ⇒ "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>k</span><span class='hs-layout'>,</span><span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>toList</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>]</span>
<a name="line-303"></a>
<a name="line-304"></a>
<a name="line-305"></a>
<a name="line-306"></a><a name="empty"></a><span class='hs-comment'>-- | The empty substituion holds nothing, and is the identity of 'compose'.</span>
<a name="line-307"></a><span class='hs-definition'>empty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Subst</span>
<a name="line-308"></a><span class='hs-definition'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Subst</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>empty</span>
<a name="line-309"></a>
<a name="line-310"></a>
<a name="line-311"></a>
<a name="line-312"></a><a name="compose"></a><span class='hs-comment'>-- | Combine two substitutions. Applying the resulting substitution means</span>
<a name="line-313"></a><span class='hs-comment'>-- applying the right hand side substitution first, and then the left hand</span>
<a name="line-314"></a><span class='hs-comment'>-- side.</span>
<a name="line-315"></a><span class='hs-comment'>--</span>
<a name="line-316"></a><span class='hs-comment'>-- In the implementation of 'compose', we don't apply the substitution to</span>
<a name="line-317"></a><span class='hs-comment'>-- anything of course, as we do not yet have anything to apply it to available.</span>
<a name="line-318"></a><span class='hs-comment'>-- Because of this, we have to incorporate the first (higher priority)</span>
<a name="line-319"></a><span class='hs-comment'>-- substitution substitution into the second one beforehand.</span>
<a name="line-320"></a><span class='hs-definition'>compose</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Subst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Subst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Subst</span>
<a name="line-321"></a><span class='hs-definition'>compose</span> <span class='hs-varid'>subst1</span> <span class='hs-varid'>subst2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>s1</span> <span class='hs-varop'>`</span><span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>union</span><span class='hs-varop'>`</span> <span class='hs-varid'>s2</span><span class='hs-layout'>)</span>
<a name="line-322"></a>  <span class='hs-keyword'>where</span>
<a name="line-323"></a>    <span class='hs-conid'>Subst</span> <span class='hs-varid'>s1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>subst1</span>
<a name="line-324"></a>    <span class='hs-conid'>Subst</span> <span class='hs-varid'>s2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substSubst</span> <span class='hs-varid'>subst1</span> <span class='hs-varid'>subst2</span>
<a name="line-325"></a>
<a name="line-326"></a>    <span class='hs-comment'>-- Apply one substitution to another, replacing all the bindings in the</span>
<a name="line-327"></a>    <span class='hs-comment'>-- second argument with their values mentioned in the first one.</span>
<a name="line-328"></a>    <span class='hs-varid'>substSubst</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Subst</span> <span class='hs-comment'>-- Apply this …</span>
<a name="line-329"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Subst</span> <span class='hs-comment'>-- … to this</span>
<a name="line-330"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Subst</span>
<a name="line-331"></a>    <span class='hs-varid'>substSubst</span> <span class='hs-varid'>s</span> <span class='hs-layout'>(</span><span class='hs-conid'>Subst</span> <span class='hs-varid'>target</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-layout'>(</span><span class='hs-varid'>substMType</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-varid'>target</span><span class='hs-layout'>)</span>
<a name="line-332"></a>
<a name="line-333"></a><span class='hs-comment'>-- I have a strong feeling that 'compose' is associative, which would make</span>
<a name="line-334"></a><span class='hs-comment'>-- 'Subst' a 'Monoid', but I wasn't able to prove this yet.</span>
<a name="line-335"></a><span class='hs-comment'>--</span>
<a name="line-336"></a><span class='hs-comment'>-- instance Monoid Subst where</span>
<a name="line-337"></a><span class='hs-comment'>--     mappend = compose</span>
<a name="line-338"></a><span class='hs-comment'>--     mempty = empty</span>
<a name="line-339"></a>
<a name="line-340"></a>
<a name="line-341"></a>
<a name="line-342"></a>
<a name="line-343"></a>
<a name="line-344"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-345"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-346"></a><span class='hs-comment'>-- * Typechecking</span>
<a name="line-347"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-348"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-349"></a>
<a name="line-350"></a><span class='hs-comment'>-- $ Typechecking does two things:</span>
<a name="line-351"></a><span class='hs-comment'>--</span>
<a name="line-352"></a><span class='hs-comment'>-- 1. If two types are not immediately identical, attempt to 'unify' them</span>
<a name="line-353"></a><span class='hs-comment'>--    to get a type compatible with both of them</span>
<a name="line-354"></a><span class='hs-comment'>-- 2. 'infer' the most general type of a value by comparing the values in its</span>
<a name="line-355"></a><span class='hs-comment'>--    definition with the 'Env'ironment</span>
<a name="line-356"></a>
<a name="line-357"></a>
<a name="line-358"></a>
<a name="line-359"></a>
<a name="line-360"></a>
<a name="line-361"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-362"></a><span class='hs-comment'>-- * Inference context</span>
<a name="line-363"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-364"></a>
<a name="line-365"></a>
<a name="line-366"></a>
<a name="line-367"></a><a name="Infer"></a><span class='hs-comment'>-- | The inference type holds a supply of unique names, and can fail with</span>
<a name="line-368"></a><a name="Infer"></a><span class='hs-comment'>-- a descriptive error if something goes wrong.</span>
<a name="line-369"></a><a name="Infer"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>Infer</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Infer</span> <span class='hs-layout'>(</span><span class='hs-conid'>ExceptT</span> <span class='hs-conid'>InferError</span> <span class='hs-layout'>(</span><span class='hs-conid'>State</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Text</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-370"></a>    <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Functor</span><span class='hs-layout'>,</span> <span class='hs-conid'>Applicative</span><span class='hs-layout'>,</span> <span class='hs-conid'>Monad</span><span class='hs-layout'>)</span>
<a name="line-371"></a>
<a name="line-372"></a>
<a name="line-373"></a><a name="InferError"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>InferError</span> <span class='hs-keyglyph'>=</span>
<a name="line-374"></a>    <span class='hs-comment'>-- | Two types that don't match were attempted to be unified.</span>
<a name="line-375"></a>      <span class='hs-conid'>CannotUnify</span> <span class='hs-conid'>MType</span> <span class='hs-conid'>MType</span>
<a name="line-376"></a>
<a name="line-377"></a>    <span class='hs-comment'>-- | A 'TVar' is bound to an 'MType' that already contains it.</span>
<a name="line-378"></a>    <span class='hs-comment'>--</span>
<a name="line-379"></a>    <span class='hs-comment'>-- The canonical example of this is @λx. x x@, where the first @x@</span>
<a name="line-380"></a>    <span class='hs-comment'>-- in the body has to have type @a → b@, and the second one @a@. Since</span>
<a name="line-381"></a>    <span class='hs-comment'>-- they're both the same @x@, this requires unification of @a@ with @a → b@,</span>
<a name="line-382"></a>    <span class='hs-comment'>-- which only works if @a = a → b = (a → b) → b = …@, yielding an infinite</span>
<a name="line-383"></a>    <span class='hs-comment'>-- type.</span>
<a name="line-384"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OccursCheckFailed</span> <span class='hs-conid'>Name</span> <span class='hs-conid'>MType</span>
<a name="line-385"></a>
<a name="line-386"></a>    <span class='hs-comment'>-- | The value of an unknown identifier was read.</span>
<a name="line-387"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnknownIdentifier</span> <span class='hs-conid'>Name</span>
<a name="line-388"></a>
<a name="line-389"></a>    <span class='hs-comment'>-- | The supply of 'fresh' variable names has run out.</span>
<a name="line-390"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OutOfFreshNames</span>
<a name="line-391"></a>
<a name="line-392"></a><a name="instance%20Pretty%20InferError"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Pretty</span> <span class='hs-conid'>InferError</span> <span class='hs-keyword'>where</span>
<a name="line-393"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>CannotUnify</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Cannot unify "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>" with "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>t2</span>
<a name="line-394"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>OccursCheckFailed</span> <span class='hs-varid'>name</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Occurs check failed: "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>" already appears in "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
<a name="line-395"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>UnknownIdentifier</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Unknown identifier: "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span>
<a name="line-396"></a>    <span class='hs-varid'>ppr</span> <span class='hs-conid'>OutOfFreshNames</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Fresh type variable name supply empty"</span>
<a name="line-397"></a>
<a name="line-398"></a>
<a name="line-399"></a>
<a name="line-400"></a><a name="runInfer"></a><span class='hs-comment'>-- | Evaluate a value in an 'Infer'ence context.</span>
<a name="line-401"></a><span class='hs-definition'>runInfer</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Text</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- ^ Supply of variable names.</span>
<a name="line-402"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-varid'>a</span> <span class='hs-comment'>-- ^ Inference data</span>
<a name="line-403"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-conid'>InferError</span> <span class='hs-varid'>a</span>
<a name="line-404"></a><span class='hs-definition'>runInfer</span> <span class='hs-varid'>supply</span> <span class='hs-layout'>(</span><span class='hs-conid'>Infer</span> <span class='hs-varid'>inf</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-405"></a>    <span class='hs-varid'>runIdentity</span> <span class='hs-layout'>(</span><span class='hs-varid'>evalStateT</span> <span class='hs-layout'>(</span><span class='hs-varid'>runExceptT</span> <span class='hs-varid'>inf</span><span class='hs-layout'>)</span> <span class='hs-varid'>infiniteSupply</span><span class='hs-layout'>)</span>
<a name="line-406"></a>  <span class='hs-keyword'>where</span>
<a name="line-407"></a>    <span class='hs-comment'>-- [a, b, c] ==&gt; [a,b,c, a1,b1,c1, a2,b2,c2, …]</span>
<a name="line-408"></a>    <span class='hs-varid'>infiniteSupply</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>supply</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>addSuffixes</span> <span class='hs-varid'>supply</span> <span class='hs-layout'>(</span><span class='hs-num'>1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integer</span><span class='hs-layout'>)</span>
<a name="line-409"></a>    <span class='hs-varid'>addSuffixes</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>addSuffix</span> <span class='hs-varid'>xs</span> <span class='hs-layout'>(</span><span class='hs-varid'>repeat</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>addSuffixes</span> <span class='hs-varid'>xs</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<a name="line-410"></a>    <span class='hs-varid'>addSuffix</span> <span class='hs-varid'>x</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>pack</span> <span class='hs-layout'>(</span><span class='hs-varid'>show</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-411"></a>
<a name="line-412"></a>
<a name="line-413"></a>
<a name="line-414"></a><a name="throw"></a><span class='hs-comment'>-- | Throw an 'InferError' in an 'Infer'ence context.</span>
<a name="line-415"></a><span class='hs-definition'>throw</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InferError</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-varid'>a</span>
<a name="line-416"></a><span class='hs-definition'>throw</span> <span class='hs-varid'>err</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Infer</span> <span class='hs-layout'>(</span><span class='hs-conid'>ExceptT</span> <span class='hs-layout'>(</span><span class='hs-conid'>StateT</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Identity</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>err</span><span class='hs-layout'>,</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-417"></a>
<a name="line-418"></a>
<a name="line-419"></a>
<a name="line-420"></a>
<a name="line-421"></a>
<a name="line-422"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-423"></a><span class='hs-comment'>-- ** Unification</span>
<a name="line-424"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-425"></a>
<a name="line-426"></a><span class='hs-comment'>-- $ Unification describes the process of making two different types compatible</span>
<a name="line-427"></a><span class='hs-comment'>-- by specializing them where needed. A desirable property to have here is</span>
<a name="line-428"></a><span class='hs-comment'>-- being able to find the most general unifier. Luckily, we'll be able to do</span>
<a name="line-429"></a><span class='hs-comment'>-- that in our type system.</span>
<a name="line-430"></a>
<a name="line-431"></a>
<a name="line-432"></a>
<a name="line-433"></a><a name="unify"></a><span class='hs-comment'>-- | The unification of two 'MType's is the most general substituion that can</span>
<a name="line-434"></a><span class='hs-comment'>-- be applied to both of them in order to yield the same result.</span>
<a name="line-435"></a><span class='hs-comment'>--</span>
<a name="line-436"></a><span class='hs-comment'>-- __Example:__ trying to unify @a -&gt; b@ with @c -&gt; (Int -&gt; Bool)@ will result</span>
<a name="line-437"></a><span class='hs-comment'>-- in a substitution of @a@ for @c@, and @b@ for @Int -&gt; Bool@.</span>
<a name="line-438"></a><span class='hs-definition'>unify</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>MType</span><span class='hs-layout'>,</span> <span class='hs-conid'>MType</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-conid'>Subst</span>
<a name="line-439"></a><span class='hs-definition'>unify</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-440"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>TFun</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span>    <span class='hs-conid'>TFun</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unifyBinary</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-441"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>TVar</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span>      <span class='hs-varid'>x</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-varop'>`bindVariableTo`</span> <span class='hs-varid'>x</span>
<a name="line-442"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span>           <span class='hs-conid'>TVar</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span> <span class='hs-varop'>`bindVariableTo`</span> <span class='hs-varid'>x</span>
<a name="line-443"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>TConst</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span>    <span class='hs-conid'>TConst</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>a</span> <span class='hs-varop'>==</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>empty</span>
<a name="line-444"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>TList</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span>     <span class='hs-conid'>TList</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unify</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-445"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>TEither</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>TEither</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unifyBinary</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-446"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>TTuple</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span>  <span class='hs-conid'>TTuple</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unifyBinary</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-447"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>throw</span> <span class='hs-layout'>(</span><span class='hs-conid'>CannotUnify</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-448"></a>
<a name="line-449"></a>  <span class='hs-keyword'>where</span>
<a name="line-450"></a>
<a name="line-451"></a>    <span class='hs-comment'>-- Unification of binary type constructors, such as functions and Either.</span>
<a name="line-452"></a>    <span class='hs-comment'>-- Unification is first done for the first operand, and assuming the</span>
<a name="line-453"></a>    <span class='hs-comment'>-- required substitution, the second operands are unified.</span>
<a name="line-454"></a>    <span class='hs-varid'>unifyBinary</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-455"></a>        <span class='hs-varid'>s1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unify</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-456"></a>        <span class='hs-keyword'>let</span> <span class='hs-varid'>b'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substMType</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>b</span>
<a name="line-457"></a>            <span class='hs-varid'>y'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substMType</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>y</span>
<a name="line-458"></a>        <span class='hs-varid'>s2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unify</span> <span class='hs-layout'>(</span><span class='hs-varid'>b'</span><span class='hs-layout'>,</span> <span class='hs-varid'>y'</span><span class='hs-layout'>)</span>
<a name="line-459"></a>        <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>s1</span> <span class='hs-varop'>`compose`</span> <span class='hs-varid'>s2</span><span class='hs-layout'>)</span>
<a name="line-460"></a>
<a name="line-461"></a>
<a name="line-462"></a>
<a name="line-463"></a><a name="bindVariableTo"></a><span class='hs-comment'>-- | Build a 'Subst'itution that binds a 'Name' of a 'TVar' to an 'MType'.</span>
<a name="line-464"></a><span class='hs-comment'>-- The resulting substitution should be idempotent, i.e. applying it more than</span>
<a name="line-465"></a><span class='hs-comment'>-- once to something should not be any different from applying it only once.</span>
<a name="line-466"></a><span class='hs-comment'>--</span>
<a name="line-467"></a><span class='hs-comment'>-- - In the simplest case, this just means building a substitution that just</span>
<a name="line-468"></a><span class='hs-comment'>--   does that.</span>
<a name="line-469"></a><span class='hs-comment'>-- - Substituting a 'Name' with a 'TVar' with the same name unifies a type</span>
<a name="line-470"></a><span class='hs-comment'>--   variable with itself, and the resulting substitution does nothing new.</span>
<a name="line-471"></a><span class='hs-comment'>-- - If the 'Name' we're trying to bind to an 'MType' already occurs in that</span>
<a name="line-472"></a><span class='hs-comment'>--   'MType', the resulting substitution would not be idempotent: the 'MType'</span>
<a name="line-473"></a><span class='hs-comment'>--   would be replaced again, yielding a different result. This is known as the</span>
<a name="line-474"></a><span class='hs-comment'>--   Occurs Check.</span>
<a name="line-475"></a><span class='hs-definition'>bindVariableTo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-conid'>Subst</span>
<a name="line-476"></a>
<a name="line-477"></a><span class='hs-definition'>bindVariableTo</span> <span class='hs-varid'>name</span> <span class='hs-layout'>(</span><span class='hs-conid'>TVar</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>boundToSelf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>empty</span>
<a name="line-478"></a>  <span class='hs-keyword'>where</span>
<a name="line-479"></a>    <span class='hs-varid'>boundToSelf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>name</span> <span class='hs-varop'>==</span> <span class='hs-varid'>v</span>
<a name="line-480"></a>
<a name="line-481"></a><span class='hs-definition'>bindVariableTo</span> <span class='hs-varid'>name</span> <span class='hs-varid'>mType</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>name</span> <span class='hs-varop'>`occursIn`</span> <span class='hs-varid'>mType</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>throw</span> <span class='hs-layout'>(</span><span class='hs-conid'>OccursCheckFailed</span> <span class='hs-varid'>name</span> <span class='hs-varid'>mType</span><span class='hs-layout'>)</span>
<a name="line-482"></a>  <span class='hs-keyword'>where</span>
<a name="line-483"></a>    <span class='hs-varid'>n</span> <span class='hs-varop'>`occursIn`</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-varop'>`</span><span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>member</span><span class='hs-varop'>`</span> <span class='hs-varid'>freeMType</span> <span class='hs-varid'>ty</span>
<a name="line-484"></a>
<a name="line-485"></a><span class='hs-definition'>bindVariableTo</span> <span class='hs-varid'>name</span> <span class='hs-varid'>mType</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-conid'>Subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-varid'>name</span> <span class='hs-varid'>mType</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-486"></a>
<a name="line-487"></a>
<a name="line-488"></a>
<a name="line-489"></a>
<a name="line-490"></a>
<a name="line-491"></a>
<a name="line-492"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-493"></a><span class='hs-comment'>-- ** Type inference</span>
<a name="line-494"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-495"></a>
<a name="line-496"></a><span class='hs-comment'>-- $ Type inference is the act of finding out a value's type by looking at the</span>
<a name="line-497"></a><span class='hs-comment'>-- environment it is in, in order to make it compatible with it.</span>
<a name="line-498"></a><span class='hs-comment'>--</span>
<a name="line-499"></a><span class='hs-comment'>-- In literature, the Hindley-Damas-Milner inference algorithm ("Algorithm W")</span>
<a name="line-500"></a><span class='hs-comment'>-- is often presented in the style of logical formulas, and below you'll find</span>
<a name="line-501"></a><span class='hs-comment'>-- that version along with code that actually does what they say.</span>
<a name="line-502"></a><span class='hs-comment'>--</span>
<a name="line-503"></a><span class='hs-comment'>-- These formulas look a bit like fractions, where the "numerator" is a</span>
<a name="line-504"></a><span class='hs-comment'>-- collection of premises, and the denominator is the consequence if all of them</span>
<a name="line-505"></a><span class='hs-comment'>-- hold.</span>
<a name="line-506"></a><span class='hs-comment'>--</span>
<a name="line-507"></a><span class='hs-comment'>-- __Example:__</span>
<a name="line-508"></a><span class='hs-comment'>--</span>
<a name="line-509"></a><span class='hs-comment'>-- @</span>
<a name="line-510"></a><span class='hs-comment'>-- Γ ⊢ even : Int → Bool   Γ ⊢ 1 : Int</span>
<a name="line-511"></a><span class='hs-comment'>-- -----------------------------------</span>
<a name="line-512"></a><span class='hs-comment'>--          Γ ⊢ even 1 : Bool</span>
<a name="line-513"></a><span class='hs-comment'>-- @</span>
<a name="line-514"></a><span class='hs-comment'>--</span>
<a name="line-515"></a><span class='hs-comment'>-- means that if we have a value of type @Int → Bool@ called "even" and a value</span>
<a name="line-516"></a><span class='hs-comment'>-- of type @Int@ called @1@, then we also have a value of type @Bool@ via</span>
<a name="line-517"></a><span class='hs-comment'>-- @even 1@ available to us.</span>
<a name="line-518"></a><span class='hs-comment'>--</span>
<a name="line-519"></a><span class='hs-comment'>-- The actual inference rules are polymorphic versions of this example, and</span>
<a name="line-520"></a><span class='hs-comment'>-- the code comments will explain each step in detail.</span>
<a name="line-521"></a>
<a name="line-522"></a>
<a name="line-523"></a>
<a name="line-524"></a>
<a name="line-525"></a>
<a name="line-526"></a>
<a name="line-527"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-528"></a><span class='hs-comment'>-- *** The language: typed lambda calculus</span>
<a name="line-529"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-530"></a>
<a name="line-531"></a>
<a name="line-532"></a>
<a name="line-533"></a><a name="Exp"></a><span class='hs-comment'>-- | The syntax tree of the language we'd like to typecheck. You can view it</span>
<a name="line-534"></a><a name="Exp"></a><span class='hs-comment'>-- as a close relative to simply typed lambda calculus, having only the most</span>
<a name="line-535"></a><a name="Exp"></a><span class='hs-comment'>-- necessary syntax elements.</span>
<a name="line-536"></a><a name="Exp"></a><span class='hs-comment'>--</span>
<a name="line-537"></a><a name="Exp"></a><span class='hs-comment'>-- __Example:__ the term @let y = λx. f x in z@ would be represented by</span>
<a name="line-538"></a><a name="Exp"></a><span class='hs-comment'>--</span>
<a name="line-539"></a><a name="Exp"></a><span class='hs-comment'>-- @</span>
<a name="line-540"></a><a name="Exp"></a><span class='hs-comment'>-- ELet "y"</span>
<a name="line-541"></a><a name="Exp"></a><span class='hs-comment'>--      (EAbs "x"</span>
<a name="line-542"></a><a name="Exp"></a><span class='hs-comment'>--            (EApp (EVar "f")</span>
<a name="line-543"></a><a name="Exp"></a><span class='hs-comment'>--                  (EVar "x")))</span>
<a name="line-544"></a><a name="Exp"></a><span class='hs-comment'>--      (EVar z)</span>
<a name="line-545"></a><a name="Exp"></a><span class='hs-comment'>-- @</span>
<a name="line-546"></a><a name="Exp"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Exp</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ELit</span> <span class='hs-conid'>Lit</span>          <span class='hs-comment'>-- ^ True, 1</span>
<a name="line-547"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EVar</span> <span class='hs-conid'>Name</span>         <span class='hs-comment'>-- ^ @x@</span>
<a name="line-548"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EApp</span> <span class='hs-conid'>Exp</span> <span class='hs-conid'>Exp</span>      <span class='hs-comment'>-- ^ @f x@</span>
<a name="line-549"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EAbs</span> <span class='hs-conid'>Name</span> <span class='hs-conid'>Exp</span>     <span class='hs-comment'>-- ^ @\x -&gt; e@</span>
<a name="line-550"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ELet</span> <span class='hs-conid'>Name</span> <span class='hs-conid'>Exp</span> <span class='hs-conid'>Exp</span> <span class='hs-comment'>-- ^ @let x = e in e'@</span>
<a name="line-551"></a>
<a name="line-552"></a>
<a name="line-553"></a>
<a name="line-554"></a><a name="Lit"></a><span class='hs-comment'>-- | Literals we'd like to support. Since we can't define new data types in our</span>
<a name="line-555"></a><a name="Lit"></a><span class='hs-comment'>-- simple type system, we'll have to hard-code the possible ones here.</span>
<a name="line-556"></a><a name="Lit"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Lit</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LBool</span> <span class='hs-conid'>Bool</span>
<a name="line-557"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LInteger</span> <span class='hs-conid'>Integer</span>
<a name="line-558"></a>
<a name="line-559"></a>
<a name="line-560"></a>
<a name="line-561"></a><a name="instance%20Pretty%20Exp"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Pretty</span> <span class='hs-conid'>Exp</span> <span class='hs-keyword'>where</span>
<a name="line-562"></a>    <span class='hs-comment'>-- ^ Omit redundant parentheses, group chained lambdas.</span>
<a name="line-563"></a>    <span class='hs-comment'>--</span>
<a name="line-564"></a>    <span class='hs-comment'>-- @</span>
<a name="line-565"></a>    <span class='hs-comment'>-- EAbs "f"</span>
<a name="line-566"></a>    <span class='hs-comment'>--   (EAbs "g"</span>
<a name="line-567"></a>    <span class='hs-comment'>--     (EAbs "x"</span>
<a name="line-568"></a>    <span class='hs-comment'>--       (EApp (EApp "f" "x")</span>
<a name="line-569"></a>    <span class='hs-comment'>--             (EApp "g" "x"))))</span>
<a name="line-570"></a>    <span class='hs-comment'>-- &gt;&gt;&gt; λf g x. f x (g x)</span>
<a name="line-571"></a>    <span class='hs-comment'>-- @</span>
<a name="line-572"></a>
<a name="line-573"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ELit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>lit</span>
<a name="line-574"></a>
<a name="line-575"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>EVar</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span>
<a name="line-576"></a>
<a name="line-577"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>EApp</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprApp1</span> <span class='hs-varid'>f</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>" "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>pprApp2</span> <span class='hs-varid'>x</span>
<a name="line-578"></a>      <span class='hs-keyword'>where</span>
<a name="line-579"></a>        <span class='hs-varid'>pprApp1</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-580"></a>            <span class='hs-varid'>eLet</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ELet</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"("</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>eLet</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>")"</span>
<a name="line-581"></a>            <span class='hs-varid'>eLet</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>EAbs</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"("</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>eLet</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>")"</span>
<a name="line-582"></a>            <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>e</span>
<a name="line-583"></a>        <span class='hs-varid'>pprApp2</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-584"></a>            <span class='hs-varid'>eApp</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>EApp</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"("</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>eApp</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>")"</span>
<a name="line-585"></a>            <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprApp1</span> <span class='hs-varid'>e</span>
<a name="line-586"></a>
<a name="line-587"></a>    <span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>EAbs</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprAbs</span> <span class='hs-conid'>True</span> <span class='hs-varid'>x</span>
<a name="line-588"></a>      <span class='hs-keyword'>where</span>
<a name="line-589"></a>        <span class='hs-varid'>pprAbs</span> <span class='hs-conid'>True</span>  <span class='hs-layout'>(</span><span class='hs-conid'>EAbs</span> <span class='hs-varid'>name</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"λ"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>pprAbs</span> <span class='hs-conid'>False</span> <span class='hs-varid'>expr</span>
<a name="line-590"></a>        <span class='hs-varid'>pprAbs</span> <span class='hs-conid'>False</span> <span class='hs-layout'>(</span><span class='hs-conid'>EAbs</span> <span class='hs-varid'>name</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>" "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>pprAbs</span> <span class='hs-conid'>False</span> <span class='hs-varid'>expr</span>
<a name="line-591"></a>        <span class='hs-varid'>pprAbs</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>". "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>expr</span>
<a name="line-592"></a>
<a name="line-593"></a>    <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ELet</span> <span class='hs-varid'>name</span> <span class='hs-varid'>value</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-594"></a>        <span class='hs-str'>"let "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>" = "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>value</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>" in "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>body</span>
<a name="line-595"></a>
<a name="line-596"></a><a name="instance%20Pretty%20Lit"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Pretty</span> <span class='hs-conid'>Lit</span> <span class='hs-keyword'>where</span>
<a name="line-597"></a>    <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-598"></a>        <span class='hs-conid'>LBool</span>    <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>showT</span> <span class='hs-varid'>b</span>
<a name="line-599"></a>        <span class='hs-conid'>LInteger</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>showT</span> <span class='hs-varid'>i</span>
<a name="line-600"></a>      <span class='hs-keyword'>where</span>
<a name="line-601"></a>        <span class='hs-varid'>showT</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Show</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Text</span>
<a name="line-602"></a>        <span class='hs-varid'>showT</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>pack</span> <span class='hs-varop'>.</span> <span class='hs-varid'>show</span>
<a name="line-603"></a>
<a name="line-604"></a><a name="instance%20IsString%20Exp"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>IsString</span> <span class='hs-conid'>Exp</span> <span class='hs-keyword'>where</span>
<a name="line-605"></a>    <span class='hs-comment'>-- ^ 'String' → 'EVar'</span>
<a name="line-606"></a>    <span class='hs-varid'>fromString</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EVar</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fromString</span>
<a name="line-607"></a>
<a name="line-608"></a>
<a name="line-609"></a>
<a name="line-610"></a>
<a name="line-611"></a>
<a name="line-612"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-613"></a><span class='hs-comment'>-- *** Some useful definitions</span>
<a name="line-614"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-615"></a>
<a name="line-616"></a>
<a name="line-617"></a>
<a name="line-618"></a><a name="fresh"></a><span class='hs-comment'>-- | Generate a fresh 'Name' in a type 'Infer'ence context. An example use case</span>
<a name="line-619"></a><span class='hs-comment'>-- of this is η expansion, which transforms @f@ into @λx. f x@, where "x" is a</span>
<a name="line-620"></a><span class='hs-comment'>-- new name, i.e. unbound in the current context.</span>
<a name="line-621"></a><span class='hs-definition'>fresh</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Infer</span> <span class='hs-conid'>MType</span>
<a name="line-622"></a><span class='hs-definition'>fresh</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>drawFromSupply</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-623"></a>    <span class='hs-conid'>Right</span> <span class='hs-varid'>name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-conid'>TVar</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>
<a name="line-624"></a>    <span class='hs-conid'>Left</span> <span class='hs-varid'>err</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>throw</span> <span class='hs-varid'>err</span>
<a name="line-625"></a>
<a name="line-626"></a>  <span class='hs-keyword'>where</span>
<a name="line-627"></a>
<a name="line-628"></a>    <span class='hs-varid'>drawFromSupply</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Infer</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-conid'>InferError</span> <span class='hs-conid'>Name</span><span class='hs-layout'>)</span>
<a name="line-629"></a>    <span class='hs-varid'>drawFromSupply</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Infer</span> <span class='hs-layout'>(</span>
<a name="line-630"></a>        <span class='hs-varid'>lift</span> <span class='hs-varid'>get</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-631"></a>            <span class='hs-varid'>s</span><span class='hs-conop'>:</span><span class='hs-varid'>upply</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>lift</span> <span class='hs-layout'>(</span><span class='hs-varid'>put</span> <span class='hs-varid'>upply</span><span class='hs-layout'>)</span>
<a name="line-632"></a>                          <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-conid'>Name</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-633"></a>            <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-conid'>OutOfFreshNames</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-634"></a>
<a name="line-635"></a>
<a name="line-636"></a>
<a name="line-637"></a><a name="liftFresh"></a><span class='hs-comment'>-- | Lift a 'fresh'ly generated 'MType' into a 'PType' by quantifying over no</span>
<a name="line-638"></a><span class='hs-comment'>-- variables. This is only safe to use if no variable duplication can be</span>
<a name="line-639"></a><span class='hs-comment'>-- ensured, as is the case when the argument is 'fresh'. Violating this rule</span>
<a name="line-640"></a><span class='hs-comment'>-- will result in (possibly silent!) name clashes.</span>
<a name="line-641"></a><span class='hs-comment'>--</span>
<a name="line-642"></a><span class='hs-comment'>-- __Example:__</span>
<a name="line-643"></a><span class='hs-comment'>--</span>
<a name="line-644"></a><span class='hs-comment'>-- @</span>
<a name="line-645"></a><span class='hs-comment'>-- a → b  ⇒  ∀∅ a → b</span>
<a name="line-646"></a><span class='hs-comment'>-- @</span>
<a name="line-647"></a><span class='hs-definition'>liftFresh</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PType</span>
<a name="line-648"></a><span class='hs-definition'>liftFresh</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Forall</span> <span class='hs-conid'>[]</span>
<a name="line-649"></a>
<a name="line-650"></a>
<a name="line-651"></a>
<a name="line-652"></a><a name="extendEnv"></a><span class='hs-comment'>-- | Add a new binding to the environment.</span>
<a name="line-653"></a><span class='hs-comment'>--</span>
<a name="line-654"></a><span class='hs-comment'>-- The Haskell equivalent would be defining a new value, for example in module</span>
<a name="line-655"></a><span class='hs-comment'>-- scope or in a @let@ block. This corresponds to the "comma" operation used</span>
<a name="line-656"></a><span class='hs-comment'>-- in formal notation,</span>
<a name="line-657"></a><span class='hs-comment'>--</span>
<a name="line-658"></a><span class='hs-comment'>-- @</span>
<a name="line-659"></a><span class='hs-comment'>-- Γ, x:σ  ≡  extendEnv Γ (x,σ)</span>
<a name="line-660"></a><span class='hs-comment'>-- @</span>
<a name="line-661"></a><span class='hs-definition'>extendEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-conid'>PType</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Env</span>
<a name="line-662"></a><span class='hs-definition'>extendEnv</span> <span class='hs-layout'>(</span><span class='hs-conid'>Env</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>pType</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Env</span> <span class='hs-layout'>(</span><span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>insert</span> <span class='hs-varid'>name</span> <span class='hs-varid'>pType</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-663"></a>
<a name="line-664"></a>
<a name="line-665"></a>
<a name="line-666"></a>
<a name="line-667"></a>
<a name="line-668"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-669"></a><span class='hs-comment'>-- *** Inferring the types of all language constructs</span>
<a name="line-670"></a><span class='hs-comment'>-- -----------------------------------------------------------------------------</span>
<a name="line-671"></a>
<a name="line-672"></a>
<a name="line-673"></a>
<a name="line-674"></a><a name="infer"></a><span class='hs-comment'>-- | Infer the type of an 'Exp'ression in an 'Env'ironment, resulting in the</span>
<a name="line-675"></a><span class='hs-comment'>-- 'Exp's 'MType'along with a substitution that has to be done in order to</span>
<a name="line-676"></a><span class='hs-comment'>-- reach this goal.</span>
<a name="line-677"></a><span class='hs-comment'>--</span>
<a name="line-678"></a><span class='hs-comment'>-- This is widely known as /Algorithm W/.</span>
<a name="line-679"></a><span class='hs-definition'>infer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-layout'>(</span><span class='hs-conid'>Subst</span><span class='hs-layout'>,</span> <span class='hs-conid'>MType</span><span class='hs-layout'>)</span>
<a name="line-680"></a><span class='hs-definition'>infer</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
<a name="line-681"></a>    <span class='hs-conid'>ELit</span> <span class='hs-varid'>lit</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>inferLit</span> <span class='hs-varid'>lit</span>
<a name="line-682"></a>    <span class='hs-conid'>EVar</span> <span class='hs-varid'>name</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>inferVar</span> <span class='hs-varid'>env</span> <span class='hs-varid'>name</span>
<a name="line-683"></a>    <span class='hs-conid'>EApp</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>inferApp</span> <span class='hs-varid'>env</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span>
<a name="line-684"></a>    <span class='hs-conid'>EAbs</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>inferAbs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span>
<a name="line-685"></a>    <span class='hs-conid'>ELet</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span> <span class='hs-varid'>e'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>inferLet</span> <span class='hs-varid'>env</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span> <span class='hs-varid'>e'</span>
<a name="line-686"></a>
<a name="line-687"></a>
<a name="line-688"></a>
<a name="line-689"></a><a name="inferLit"></a><span class='hs-comment'>-- | Literals such as 'True' and '1' have their types hard-coded.</span>
<a name="line-690"></a><span class='hs-definition'>inferLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Lit</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-layout'>(</span><span class='hs-conid'>Subst</span><span class='hs-layout'>,</span> <span class='hs-conid'>MType</span><span class='hs-layout'>)</span>
<a name="line-691"></a><span class='hs-definition'>inferLit</span> <span class='hs-varid'>lit</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>empty</span><span class='hs-layout'>,</span> <span class='hs-conid'>TConst</span> <span class='hs-varid'>litTy</span><span class='hs-layout'>)</span>
<a name="line-692"></a>  <span class='hs-keyword'>where</span>
<a name="line-693"></a>    <span class='hs-varid'>litTy</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lit</span> <span class='hs-keyword'>of</span>
<a name="line-694"></a>        <span class='hs-conid'>LBool</span>    <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"Bool"</span>
<a name="line-695"></a>        <span class='hs-conid'>LInteger</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"Integer"</span>
<a name="line-696"></a>
<a name="line-697"></a>
<a name="line-698"></a>
<a name="line-699"></a><a name="inferVar"></a><span class='hs-comment'>-- | Inferring the type of a variable is done via</span>
<a name="line-700"></a><span class='hs-comment'>--</span>
<a name="line-701"></a><span class='hs-comment'>-- @</span>
<a name="line-702"></a><span class='hs-comment'>-- x:σ ∈ Γ   τ = instantiate(σ)</span>
<a name="line-703"></a><span class='hs-comment'>-- ----------------------------  [Var]</span>
<a name="line-704"></a><span class='hs-comment'>--            Γ ⊢ x:τ</span>
<a name="line-705"></a><span class='hs-comment'>-- @</span>
<a name="line-706"></a><span class='hs-comment'>--</span>
<a name="line-707"></a><span class='hs-comment'>-- which simply means that if @x@ is available in polymorphic form, then we have</span>
<a name="line-708"></a><span class='hs-comment'>-- it available in all possible instantiations of that σ type. This allows us</span>
<a name="line-709"></a><span class='hs-comment'>-- to take a σ type, and specialize it to our specific needs.</span>
<a name="line-710"></a><span class='hs-definition'>inferVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-layout'>(</span><span class='hs-conid'>Subst</span><span class='hs-layout'>,</span> <span class='hs-conid'>MType</span><span class='hs-layout'>)</span>
<a name="line-711"></a><span class='hs-definition'>inferVar</span> <span class='hs-varid'>env</span> <span class='hs-varid'>name</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-712"></a>    <span class='hs-varid'>sigma</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>name</span> <span class='hs-comment'>-- x:σ ∈ Γ</span>
<a name="line-713"></a>    <span class='hs-varid'>tau</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instantiate</span> <span class='hs-varid'>sigma</span>    <span class='hs-comment'>-- τ = instantiate(σ)</span>
<a name="line-714"></a>                                <span class='hs-comment'>-- ------------------</span>
<a name="line-715"></a>    <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>empty</span><span class='hs-layout'>,</span> <span class='hs-varid'>tau</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- Γ ⊢ x:τ</span>
<a name="line-716"></a>
<a name="line-717"></a>
<a name="line-718"></a>
<a name="line-719"></a><a name="lookupEnv"></a><span class='hs-comment'>-- | Look up the 'PType' of a 'Name' in the 'Env'ironment.</span>
<a name="line-720"></a><span class='hs-comment'>--</span>
<a name="line-721"></a><span class='hs-comment'>-- To give a Haskell analogon, looking up @id@ when @Prelude@ is loaded,</span>
<a name="line-722"></a><span class='hs-comment'>-- the resulting 'PType' would be @id@'s type, namely @forall a. a -&gt; a@.</span>
<a name="line-723"></a><span class='hs-definition'>lookupEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-conid'>PType</span>
<a name="line-724"></a><span class='hs-definition'>lookupEnv</span> <span class='hs-layout'>(</span><span class='hs-conid'>Env</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>name</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>lookup</span> <span class='hs-varid'>name</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>of</span>
<a name="line-725"></a>    <span class='hs-conid'>Just</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>x</span>
<a name="line-726"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>throw</span> <span class='hs-layout'>(</span><span class='hs-conid'>UnknownIdentifier</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>
<a name="line-727"></a>
<a name="line-728"></a>
<a name="line-729"></a>
<a name="line-730"></a><a name="instantiate"></a><span class='hs-comment'>-- | Bind all quantified variables of a 'PType' to 'fresh' type variables.</span>
<a name="line-731"></a><span class='hs-comment'>--</span>
<a name="line-732"></a><span class='hs-comment'>-- __Example:__ instantiating @forall a. a -&gt; b -&gt; a@ results in the 'MType'</span>
<a name="line-733"></a><span class='hs-comment'>-- @a -&gt; b -&gt; a@, where @a@ is a fresh name (to avoid shadowing issues).</span>
<a name="line-734"></a><span class='hs-comment'>--</span>
<a name="line-735"></a><span class='hs-comment'>-- You can picture the 'PType' to be the prototype converted to an instantiated</span>
<a name="line-736"></a><span class='hs-comment'>-- 'MType', which can now be used in the unification process.</span>
<a name="line-737"></a><span class='hs-comment'>--</span>
<a name="line-738"></a><span class='hs-comment'>-- Another way of looking at it is by simply forgetting which variables were</span>
<a name="line-739"></a><span class='hs-comment'>-- quantified over, carefully avoiding name clashes when doing so.</span>
<a name="line-740"></a><span class='hs-definition'>instantiate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-conid'>MType</span>
<a name="line-741"></a><span class='hs-definition'>instantiate</span> <span class='hs-layout'>(</span><span class='hs-conid'>Forall</span> <span class='hs-varid'>qs</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-742"></a>    <span class='hs-varid'>subst</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>substituteAllWithFresh</span> <span class='hs-varid'>qs</span>
<a name="line-743"></a>    <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>substMType</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-744"></a>
<a name="line-745"></a>  <span class='hs-keyword'>where</span>
<a name="line-746"></a>    <span class='hs-comment'>-- For each given name, add a substitution from that name to a fresh type</span>
<a name="line-747"></a>    <span class='hs-comment'>-- variable to the result.</span>
<a name="line-748"></a>    <span class='hs-varid'>substituteAllWithFresh</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Set</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-conid'>Subst</span>
<a name="line-749"></a>    <span class='hs-varid'>substituteAllWithFresh</span> <span class='hs-varid'>xs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-750"></a>        <span class='hs-keyword'>let</span> <span class='hs-varid'>freshSubstActions</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>fromSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-varid'>fresh</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span>
<a name="line-751"></a>        <span class='hs-varid'>freshSubsts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>sequenceA</span> <span class='hs-varid'>freshSubstActions</span>
<a name="line-752"></a>        <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-conid'>Subst</span> <span class='hs-varid'>freshSubsts</span><span class='hs-layout'>)</span>
<a name="line-753"></a>
<a name="line-754"></a>
<a name="line-755"></a>
<a name="line-756"></a><a name="inferApp"></a><span class='hs-comment'>-- | Function application captures the fact that if we have a function and an</span>
<a name="line-757"></a><span class='hs-comment'>-- argument we can give to that function, we also have the result value of the</span>
<a name="line-758"></a><span class='hs-comment'>-- result type available to us.</span>
<a name="line-759"></a><span class='hs-comment'>--</span>
<a name="line-760"></a><span class='hs-comment'>-- @</span>
<a name="line-761"></a><span class='hs-comment'>-- Γ ⊢ f : fτ   Γ ⊢ x : xτ   fxτ = fresh   unify(fτ, xτ → fxτ)</span>
<a name="line-762"></a><span class='hs-comment'>-- -----------------------------------------------------------  [App]</span>
<a name="line-763"></a><span class='hs-comment'>--                       Γ ⊢ f x : fxτ</span>
<a name="line-764"></a><span class='hs-comment'>-- @</span>
<a name="line-765"></a><span class='hs-comment'>--</span>
<a name="line-766"></a><span class='hs-comment'>-- This rule is however a bit backwards to our normal way of thinking about</span>
<a name="line-767"></a><span class='hs-comment'>-- typing function application: instead of applying a function to a value</span>
<a name="line-768"></a><span class='hs-comment'>-- and investigating the result, we hypothesize the function type @xτ → fxτ@</span>
<a name="line-769"></a><span class='hs-comment'>-- of mappting the argument @xτ@ to the result type @fxτ@, and make sure this</span>
<a name="line-770"></a><span class='hs-comment'>-- mapping unifies with the function @f:fτ@ given.</span>
<a name="line-771"></a><span class='hs-definition'>inferApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-layout'>(</span><span class='hs-conid'>Subst</span><span class='hs-layout'>,</span> <span class='hs-conid'>MType</span><span class='hs-layout'>)</span>
<a name="line-772"></a><span class='hs-definition'>inferApp</span> <span class='hs-varid'>env</span> <span class='hs-varid'>f</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-773"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>fTau</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>infer</span> <span class='hs-varid'>env</span> <span class='hs-varid'>f</span>                         <span class='hs-comment'>-- f : fτ</span>
<a name="line-774"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>s2</span><span class='hs-layout'>,</span> <span class='hs-varid'>xTau</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>infer</span> <span class='hs-layout'>(</span><span class='hs-varid'>substEnv</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span>           <span class='hs-comment'>-- x : xτ</span>
<a name="line-775"></a>    <span class='hs-varid'>fxTau</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>fresh</span>                                    <span class='hs-comment'>-- fxτ = fresh</span>
<a name="line-776"></a>    <span class='hs-varid'>s3</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unify</span> <span class='hs-layout'>(</span><span class='hs-varid'>substMType</span> <span class='hs-varid'>s2</span> <span class='hs-varid'>fTau</span><span class='hs-layout'>,</span> <span class='hs-conid'>TFun</span> <span class='hs-varid'>xTau</span> <span class='hs-varid'>fxTau</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- unify (fτ, xτ → fxτ)</span>
<a name="line-777"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>s3</span> <span class='hs-varop'>`compose`</span> <span class='hs-varid'>s2</span> <span class='hs-varop'>`compose`</span> <span class='hs-varid'>s1</span>              <span class='hs-comment'>-- --------------------</span>
<a name="line-778"></a>    <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-varid'>substMType</span> <span class='hs-varid'>s3</span> <span class='hs-varid'>fxTau</span><span class='hs-layout'>)</span>                     <span class='hs-comment'>-- f x : fxτ</span>
<a name="line-779"></a>
<a name="line-780"></a>
<a name="line-781"></a>
<a name="line-782"></a><a name="inferAbs"></a><span class='hs-comment'>-- | Lambda abstraction is based on the fact that when we introduce a new</span>
<a name="line-783"></a><span class='hs-comment'>-- variable, the resulting lambda maps from that variable's type to the type</span>
<a name="line-784"></a><span class='hs-comment'>-- of the body.</span>
<a name="line-785"></a><span class='hs-comment'>--</span>
<a name="line-786"></a><span class='hs-comment'>-- @</span>
<a name="line-787"></a><span class='hs-comment'>-- τ = fresh   σ = liftFresh(τ)   Γ, x:σ ⊢ e:τ'</span>
<a name="line-788"></a><span class='hs-comment'>-- --------------------------------------------  [Abs]</span>
<a name="line-789"></a><span class='hs-comment'>--                Γ ⊢ λx.e : τ→τ'</span>
<a name="line-790"></a><span class='hs-comment'>-- @</span>
<a name="line-791"></a><span class='hs-comment'>--</span>
<a name="line-792"></a><span class='hs-comment'>-- Here, @Γ, x:τ@ is @Γ@ extended by one additional mapping, namely @x:τ@.</span>
<a name="line-793"></a><span class='hs-comment'>--</span>
<a name="line-794"></a><span class='hs-comment'>-- Abstraction is typed by extending the environment by a new 'MType', and if</span>
<a name="line-795"></a><span class='hs-comment'>-- under this assumption we can construct a function mapping to a value of</span>
<a name="line-796"></a><span class='hs-comment'>-- that type, we can say that the lambda takes a value and maps to it.</span>
<a name="line-797"></a><span class='hs-definition'>inferAbs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-layout'>(</span><span class='hs-conid'>Subst</span><span class='hs-layout'>,</span> <span class='hs-conid'>MType</span><span class='hs-layout'>)</span>
<a name="line-798"></a><span class='hs-definition'>inferAbs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-799"></a>    <span class='hs-varid'>tau</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>fresh</span>                           <span class='hs-comment'>-- τ = fresh</span>
<a name="line-800"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>sigma</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftFresh</span> <span class='hs-varid'>tau</span>              <span class='hs-comment'>-- σ = liftFresh τ</span>
<a name="line-801"></a>        <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendEnv</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>sigma</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Γ, x:σ …</span>
<a name="line-802"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-varid'>tau'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>infer</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>e</span>              <span class='hs-comment'>--        … ⊢ e:τ'</span>
<a name="line-803"></a>                                           <span class='hs-comment'>-- ---------------</span>
<a name="line-804"></a>    <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-conid'>TFun</span> <span class='hs-layout'>(</span><span class='hs-varid'>substMType</span> <span class='hs-varid'>s</span> <span class='hs-varid'>tau</span><span class='hs-layout'>)</span> <span class='hs-varid'>tau'</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- λx.e : τ→τ'</span>
<a name="line-805"></a>
<a name="line-806"></a>
<a name="line-807"></a>
<a name="line-808"></a><a name="inferLet"></a><span class='hs-comment'>-- | A let binding allows extending the environment with new bindings in a</span>
<a name="line-809"></a><span class='hs-comment'>-- principled manner. To do this, we first have to typecheck the expression</span>
<a name="line-810"></a><span class='hs-comment'>-- to be introduced. The result of this is then generalized to a PType, since</span>
<a name="line-811"></a><span class='hs-comment'>-- let bindings introduce new polymorphic values, and then added to the</span>
<a name="line-812"></a><span class='hs-comment'>-- environment. Now we can finally typecheck the body of the "in" part of the</span>
<a name="line-813"></a><span class='hs-comment'>-- let binding.</span>
<a name="line-814"></a><span class='hs-comment'>--</span>
<a name="line-815"></a><span class='hs-comment'>-- @</span>
<a name="line-816"></a><span class='hs-comment'>-- Γ ⊢ e:τ   σ = gen(Γ,τ)   Γ, x:σ ⊢ e':τ'</span>
<a name="line-817"></a><span class='hs-comment'>-- ---------------------------------------  [Let]</span>
<a name="line-818"></a><span class='hs-comment'>--         Γ ⊢ let x = e in e' : τ'</span>
<a name="line-819"></a><span class='hs-comment'>-- @</span>
<a name="line-820"></a><span class='hs-definition'>inferLet</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Infer</span> <span class='hs-layout'>(</span><span class='hs-conid'>Subst</span><span class='hs-layout'>,</span> <span class='hs-conid'>MType</span><span class='hs-layout'>)</span>
<a name="line-821"></a><span class='hs-definition'>inferLet</span> <span class='hs-varid'>env</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span> <span class='hs-varid'>e'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-822"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tau</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>infer</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span>              <span class='hs-comment'>-- Γ ⊢ e:τ</span>
<a name="line-823"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substEnv</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>env</span>
<a name="line-824"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>sigma</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>generalize</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>tau</span>       <span class='hs-comment'>-- σ = gen(Γ,τ)</span>
<a name="line-825"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>env''</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendEnv</span> <span class='hs-varid'>env'</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>sigma</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Γ, x:σ</span>
<a name="line-826"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>s2</span><span class='hs-layout'>,</span> <span class='hs-varid'>tau'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>infer</span> <span class='hs-varid'>env''</span> <span class='hs-varid'>e'</span>          <span class='hs-comment'>-- Γ ⊢ …</span>
<a name="line-827"></a>                                          <span class='hs-comment'>-- --------------------------</span>
<a name="line-828"></a>    <span class='hs-varid'>pure</span> <span class='hs-layout'>(</span><span class='hs-varid'>s2</span> <span class='hs-varop'>`compose`</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tau'</span><span class='hs-layout'>)</span>          <span class='hs-comment'>--     … let x = e in e' : τ'</span>
<a name="line-829"></a>
<a name="line-830"></a>
<a name="line-831"></a>
<a name="line-832"></a><a name="generalize"></a><span class='hs-comment'>-- | Generalize an 'MType' to a 'PType' by universally quantifying over</span>
<a name="line-833"></a><span class='hs-comment'>-- all the type variables contained in it, except those already mentioned</span>
<a name="line-834"></a><span class='hs-comment'>-- in the environment.</span>
<a name="line-835"></a><span class='hs-comment'>--</span>
<a name="line-836"></a><span class='hs-comment'>-- __Example:__ Generalizing @forall a. a -&gt; b -&gt; a@ yields</span>
<a name="line-837"></a><span class='hs-comment'>-- @forall a b. a -&gt; b -&gt; a@.</span>
<a name="line-838"></a><span class='hs-comment'>--</span>
<a name="line-839"></a><span class='hs-comment'>-- @</span>
<a name="line-840"></a><span class='hs-comment'>-- gen(Γ,τ) = ∀{α}. σ</span>
<a name="line-841"></a><span class='hs-comment'>--     where {α} = free(τ) – free(Γ)</span>
<a name="line-842"></a><span class='hs-comment'>-- @</span>
<a name="line-843"></a><span class='hs-definition'>generalize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PType</span>
<a name="line-844"></a><span class='hs-definition'>generalize</span> <span class='hs-varid'>env</span> <span class='hs-varid'>mType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Forall</span> <span class='hs-varid'>qs</span> <span class='hs-varid'>mType</span>
<a name="line-845"></a>  <span class='hs-keyword'>where</span>
<a name="line-846"></a>    <span class='hs-varid'>qs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>freeMType</span> <span class='hs-varid'>mType</span> <span class='hs-varop'>`</span><span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>difference</span><span class='hs-varop'>`</span> <span class='hs-varid'>freeEnv</span> <span class='hs-varid'>env</span>
<a name="line-847"></a>
<a name="line-848"></a>
<a name="line-849"></a>
<a name="line-850"></a>
<a name="line-851"></a>
<a name="line-852"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-853"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-854"></a><span class='hs-comment'>-- * Testing</span>
<a name="line-855"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-856"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-857"></a>
<a name="line-858"></a>
<a name="line-859"></a>
<a name="line-860"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-861"></a><span class='hs-comment'>-- ** A small custom Prelude</span>
<a name="line-862"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-863"></a>
<a name="line-864"></a>
<a name="line-865"></a>
<a name="line-866"></a><a name="prelude"></a><span class='hs-definition'>prelude</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span>
<a name="line-867"></a><span class='hs-definition'>prelude</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Env</span> <span class='hs-layout'>(</span><span class='hs-conid'>M</span><span class='hs-varop'>.</span><span class='hs-varid'>fromList</span>
<a name="line-868"></a>    <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-str'>"(*)"</span><span class='hs-layout'>,</span>        <span class='hs-conid'>Forall</span> <span class='hs-conid'>[]</span>              <span class='hs-layout'>(</span><span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tInteger</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-869"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"(+)"</span><span class='hs-layout'>,</span>        <span class='hs-conid'>Forall</span> <span class='hs-conid'>[]</span>              <span class='hs-layout'>(</span><span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tInteger</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-870"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"(,)"</span><span class='hs-layout'>,</span>        <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-layout'>,</span><span class='hs-str'>"b"</span><span class='hs-keyglyph'>]</span>       <span class='hs-layout'>(</span><span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"b"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-conid'>TTuple</span> <span class='hs-str'>"a"</span> <span class='hs-str'>"b"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-871"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"(-)"</span><span class='hs-layout'>,</span>        <span class='hs-conid'>Forall</span> <span class='hs-conid'>[]</span>              <span class='hs-layout'>(</span><span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tInteger</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-872"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"(.)"</span><span class='hs-layout'>,</span>        <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-layout'>,</span> <span class='hs-str'>"b"</span><span class='hs-layout'>,</span> <span class='hs-str'>"c"</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-str'>"b"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"c"</span><span class='hs-layout'>)</span> <span class='hs-varop'>~&gt;</span> <span class='hs-layout'>(</span><span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"b"</span><span class='hs-layout'>)</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"c"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-873"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"(&lt;)"</span><span class='hs-layout'>,</span>        <span class='hs-conid'>Forall</span> <span class='hs-conid'>[]</span>              <span class='hs-layout'>(</span><span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tBool</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-874"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"(&lt;=)"</span><span class='hs-layout'>,</span>       <span class='hs-conid'>Forall</span> <span class='hs-conid'>[]</span>              <span class='hs-layout'>(</span><span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tBool</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-875"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"(&gt;)"</span><span class='hs-layout'>,</span>        <span class='hs-conid'>Forall</span> <span class='hs-conid'>[]</span>              <span class='hs-layout'>(</span><span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tBool</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-876"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"(&gt;=)"</span><span class='hs-layout'>,</span>       <span class='hs-conid'>Forall</span> <span class='hs-conid'>[]</span>              <span class='hs-layout'>(</span><span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tInteger</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tBool</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-877"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"const"</span><span class='hs-layout'>,</span>      <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-layout'>,</span><span class='hs-str'>"b"</span><span class='hs-keyglyph'>]</span>       <span class='hs-layout'>(</span><span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"b"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"a"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-878"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"Cont/&gt;&gt;="</span><span class='hs-layout'>,</span>   <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-keyglyph'>]</span>           <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"r"</span><span class='hs-layout'>)</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"r"</span><span class='hs-layout'>)</span> <span class='hs-varop'>~&gt;</span> <span class='hs-layout'>(</span><span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-str'>"b"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"r"</span><span class='hs-layout'>)</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"r"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>~&gt;</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-str'>"b"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"r"</span><span class='hs-layout'>)</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"r"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-879"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"find"</span><span class='hs-layout'>,</span>       <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-layout'>,</span><span class='hs-str'>"b"</span><span class='hs-keyglyph'>]</span>       <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tBool</span><span class='hs-layout'>)</span> <span class='hs-varop'>~&gt;</span> <span class='hs-conid'>TList</span> <span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tMaybe</span> <span class='hs-str'>"a"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-880"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"fix"</span><span class='hs-layout'>,</span>        <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-keyglyph'>]</span>           <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"a"</span><span class='hs-layout'>)</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"a"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-881"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"foldr"</span><span class='hs-layout'>,</span>      <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-layout'>,</span><span class='hs-str'>"b"</span><span class='hs-keyglyph'>]</span>       <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"b"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"b"</span><span class='hs-layout'>)</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"b"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-conid'>TList</span> <span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"b"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-882"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"id"</span><span class='hs-layout'>,</span>         <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-keyglyph'>]</span>           <span class='hs-layout'>(</span><span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"a"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-883"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"ifThenElse"</span><span class='hs-layout'>,</span> <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-keyglyph'>]</span>           <span class='hs-layout'>(</span><span class='hs-varid'>tBool</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"a"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-884"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"Left"</span><span class='hs-layout'>,</span>       <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-layout'>,</span><span class='hs-str'>"b"</span><span class='hs-keyglyph'>]</span>       <span class='hs-layout'>(</span><span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-conid'>TEither</span> <span class='hs-str'>"a"</span> <span class='hs-str'>"b"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-885"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"length"</span><span class='hs-layout'>,</span>     <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-keyglyph'>]</span>           <span class='hs-layout'>(</span><span class='hs-conid'>TList</span> <span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-varid'>tInteger</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-886"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"map"</span><span class='hs-layout'>,</span>        <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-layout'>,</span><span class='hs-str'>"b"</span><span class='hs-keyglyph'>]</span>       <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-str'>"b"</span><span class='hs-layout'>)</span> <span class='hs-varop'>~&gt;</span> <span class='hs-conid'>TList</span> <span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-conid'>TList</span> <span class='hs-str'>"b"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-887"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"reverse"</span><span class='hs-layout'>,</span>    <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-keyglyph'>]</span>           <span class='hs-layout'>(</span><span class='hs-conid'>TList</span> <span class='hs-str'>"a"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-conid'>TList</span> <span class='hs-str'>"a"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-888"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-str'>"Right"</span><span class='hs-layout'>,</span>      <span class='hs-conid'>Forall</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"a"</span><span class='hs-layout'>,</span><span class='hs-str'>"b"</span><span class='hs-keyglyph'>]</span>       <span class='hs-layout'>(</span><span class='hs-str'>"b"</span> <span class='hs-varop'>~&gt;</span> <span class='hs-conid'>TEither</span> <span class='hs-str'>"a"</span> <span class='hs-str'>"b"</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-889"></a>    <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-890"></a>  <span class='hs-keyword'>where</span>
<a name="line-891"></a>    <span class='hs-varid'>tBool</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TConst</span> <span class='hs-str'>"Bool"</span>
<a name="line-892"></a>    <span class='hs-varid'>tInteger</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TConst</span> <span class='hs-str'>"Integer"</span>
<a name="line-893"></a>    <span class='hs-varid'>tMaybe</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TEither</span> <span class='hs-layout'>(</span><span class='hs-conid'>TConst</span> <span class='hs-str'>"()"</span><span class='hs-layout'>)</span>
<a name="line-894"></a>
<a name="line-895"></a>
<a name="line-896"></a>
<a name="line-897"></a><a name="~%3e"></a><span class='hs-comment'>-- | Synonym for 'TFun' to make writing type signatures easier.</span>
<a name="line-898"></a><span class='hs-comment'>--</span>
<a name="line-899"></a><span class='hs-comment'>-- Instead of</span>
<a name="line-900"></a><span class='hs-comment'>--</span>
<a name="line-901"></a><span class='hs-comment'>-- @</span>
<a name="line-902"></a><span class='hs-comment'>-- Forall ["a","b"] (TFun "a" (TFun "b" "a"))</span>
<a name="line-903"></a><span class='hs-comment'>-- @</span>
<a name="line-904"></a><span class='hs-comment'>--</span>
<a name="line-905"></a><span class='hs-comment'>-- we can write</span>
<a name="line-906"></a><span class='hs-comment'>--</span>
<a name="line-907"></a><span class='hs-comment'>-- @</span>
<a name="line-908"></a><span class='hs-comment'>-- Forall ["a","b"] ("a" ~&gt; "b" ~&gt; "a")</span>
<a name="line-909"></a><span class='hs-comment'>-- @</span>
<a name="line-910"></a><span class='hs-layout'>(</span><span class='hs-varop'>~&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MType</span>
<a name="line-911"></a><span class='hs-layout'>(</span><span class='hs-varop'>~&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TFun</span>
<a name="line-912"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>9</span> <span class='hs-varop'>~&gt;</span>
<a name="line-913"></a>
<a name="line-914"></a>
<a name="line-915"></a>
<a name="line-916"></a><a name="defaultSupply"></a><span class='hs-comment'>-- | Supply to draw fresh type variable names from</span>
<a name="line-917"></a><span class='hs-definition'>defaultSupply</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Text</span><span class='hs-keyglyph'>]</span>
<a name="line-918"></a><span class='hs-definition'>defaultSupply</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>pack</span> <span class='hs-varop'>.</span> <span class='hs-varid'>pure</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-chr'>'a'</span><span class='hs-keyglyph'>..</span><span class='hs-chr'>'z'</span><span class='hs-keyglyph'>]</span>
<a name="line-919"></a>
<a name="line-920"></a>
<a name="line-921"></a>
<a name="line-922"></a>
<a name="line-923"></a>
<a name="line-924"></a>
<a name="line-925"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-926"></a><span class='hs-comment'>-- ** Run it!</span>
<a name="line-927"></a><span class='hs-comment'>-- #############################################################################</span>
<a name="line-928"></a>
<a name="line-929"></a>
<a name="line-930"></a>
<a name="line-931"></a><a name="main"></a><span class='hs-comment'>-- | Run type inference on a cuple of values</span>
<a name="line-932"></a><span class='hs-definition'>main</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-933"></a><span class='hs-definition'>main</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-934"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>run</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>putStrLn</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-str'>"  "</span> <span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>showType</span> <span class='hs-varid'>prelude</span> <span class='hs-varid'>defaultSupply</span>
<a name="line-935"></a>    <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>putStrLn</span> <span class='hs-str'>"Well-typed:"</span>
<a name="line-936"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>lambda</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"x"</span><span class='hs-keyglyph'>]</span> <span class='hs-str'>"x"</span><span class='hs-layout'>)</span>
<a name="line-937"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>lambda</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"f"</span><span class='hs-layout'>,</span><span class='hs-str'>"g"</span><span class='hs-layout'>,</span><span class='hs-str'>"x"</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"f"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"x"</span><span class='hs-layout'>,</span> <span class='hs-varid'>apply</span> <span class='hs-str'>"g"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"x"</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-938"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>lambda</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"f"</span><span class='hs-layout'>,</span><span class='hs-str'>"g"</span><span class='hs-layout'>,</span><span class='hs-str'>"x"</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"f"</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>apply</span> <span class='hs-str'>"g"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"x"</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-939"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"find"</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>lambda</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"x"</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"(&gt;)"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"x"</span><span class='hs-layout'>,</span> <span class='hs-varid'>int</span> <span class='hs-num'>0</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-940"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>lambda</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"f"</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"(.)"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"reverse"</span><span class='hs-layout'>,</span> <span class='hs-varid'>apply</span> <span class='hs-str'>"map"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"f"</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-941"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"map"</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>apply</span> <span class='hs-str'>"map"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"map"</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-942"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"(*)"</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>int</span> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-varid'>int</span> <span class='hs-num'>2</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-943"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"foldr"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"(+)"</span><span class='hs-layout'>,</span> <span class='hs-varid'>int</span> <span class='hs-num'>0</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-944"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"map"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"length"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-945"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"map"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"map"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-946"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>lambda</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"x"</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"ifThenElse"</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>apply</span> <span class='hs-str'>"(&lt;)"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"x"</span><span class='hs-layout'>,</span> <span class='hs-varid'>int</span> <span class='hs-num'>0</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>int</span> <span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-str'>"x"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-947"></a>    <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>putStrLn</span> <span class='hs-str'>"Ill-typed:"</span>
<a name="line-948"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"(*)"</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>int</span> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-varid'>bool</span> <span class='hs-conid'>True</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-949"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"foldr"</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>int</span> <span class='hs-num'>1</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-950"></a>    <span class='hs-varid'>run</span> <span class='hs-layout'>(</span><span class='hs-varid'>lambda</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"x"</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>apply</span> <span class='hs-str'>"x"</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"x"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-951"></a>
<a name="line-952"></a>
<a name="line-953"></a>
<a name="line-954"></a><a name="lambda"></a><span class='hs-comment'>-- | Build multiple lambda bindings.</span>
<a name="line-955"></a><span class='hs-comment'>--</span>
<a name="line-956"></a><span class='hs-comment'>-- Instead of</span>
<a name="line-957"></a><span class='hs-comment'>--</span>
<a name="line-958"></a><span class='hs-comment'>-- @</span>
<a name="line-959"></a><span class='hs-comment'>-- EAbs "f" (EAbs "x" (EApp "f" "x"))</span>
<a name="line-960"></a><span class='hs-comment'>-- @</span>
<a name="line-961"></a><span class='hs-comment'>--</span>
<a name="line-962"></a><span class='hs-comment'>-- we can write</span>
<a name="line-963"></a><span class='hs-comment'>--</span>
<a name="line-964"></a><span class='hs-comment'>-- @</span>
<a name="line-965"></a><span class='hs-comment'>-- lambda ["f", "x"] (EApp "f" "x")</span>
<a name="line-966"></a><span class='hs-comment'>-- @</span>
<a name="line-967"></a><span class='hs-comment'>--</span>
<a name="line-968"></a><span class='hs-comment'>-- for</span>
<a name="line-969"></a><span class='hs-comment'>--</span>
<a name="line-970"></a><span class='hs-comment'>-- @</span>
<a name="line-971"></a><span class='hs-comment'>-- λf x. f x</span>
<a name="line-972"></a><span class='hs-comment'>-- @</span>
<a name="line-973"></a><span class='hs-definition'>lambda</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span>
<a name="line-974"></a><span class='hs-definition'>lambda</span> <span class='hs-varid'>names</span> <span class='hs-varid'>expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-conid'>EAbs</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>names</span>
<a name="line-975"></a>
<a name="line-976"></a>
<a name="line-977"></a>
<a name="line-978"></a><a name="apply"></a><span class='hs-comment'>-- | Apply a function to multiple arguments.</span>
<a name="line-979"></a><span class='hs-comment'>--</span>
<a name="line-980"></a><span class='hs-comment'>-- Instead of</span>
<a name="line-981"></a><span class='hs-comment'>--</span>
<a name="line-982"></a><span class='hs-comment'>-- @</span>
<a name="line-983"></a><span class='hs-comment'>-- EApp (EApp (EApp "f" "x") "y") "z")</span>
<a name="line-984"></a><span class='hs-comment'>-- @</span>
<a name="line-985"></a><span class='hs-comment'>--</span>
<a name="line-986"></a><span class='hs-comment'>-- we can write</span>
<a name="line-987"></a><span class='hs-comment'>--</span>
<a name="line-988"></a><span class='hs-comment'>-- @</span>
<a name="line-989"></a><span class='hs-comment'>-- apply "f" ["x", "y", "z"]</span>
<a name="line-990"></a><span class='hs-comment'>-- @</span>
<a name="line-991"></a><span class='hs-comment'>--</span>
<a name="line-992"></a><span class='hs-comment'>-- for</span>
<a name="line-993"></a><span class='hs-comment'>--</span>
<a name="line-994"></a><span class='hs-comment'>-- @</span>
<a name="line-995"></a><span class='hs-comment'>-- f x y z</span>
<a name="line-996"></a><span class='hs-comment'>-- @</span>
<a name="line-997"></a><span class='hs-definition'>apply</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Exp</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Exp</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span>
<a name="line-998"></a><span class='hs-definition'>apply</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-conid'>EApp</span>
<a name="line-999"></a>
<a name="line-1000"></a>
<a name="line-1001"></a>
<a name="line-1002"></a><a name="int"></a><span class='hs-comment'>-- | Construct an integer literal.</span>
<a name="line-1003"></a><span class='hs-definition'>int</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span>
<a name="line-1004"></a><span class='hs-definition'>int</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ELit</span> <span class='hs-varop'>.</span> <span class='hs-conid'>LInteger</span>
<a name="line-1005"></a>
<a name="line-1006"></a>
<a name="line-1007"></a>
<a name="line-1008"></a><a name="bool"></a><span class='hs-comment'>-- | Construct a boolean literal.</span>
<a name="line-1009"></a><span class='hs-definition'>bool</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span>
<a name="line-1010"></a><span class='hs-definition'>bool</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ELit</span> <span class='hs-varop'>.</span> <span class='hs-conid'>LBool</span>
<a name="line-1011"></a>
<a name="line-1012"></a>
<a name="line-1013"></a>
<a name="line-1014"></a><a name="showType"></a><span class='hs-comment'>-- | Convenience function to run type inference algorithm</span>
<a name="line-1015"></a><span class='hs-definition'>showType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Env</span>    <span class='hs-comment'>-- ^ Starting environment, e.g. 'prelude'.</span>
<a name="line-1016"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Text</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- ^ Fresh variable name supply. Should be non-empty.</span>
<a name="line-1017"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exp</span>    <span class='hs-comment'>-- ^ Expression to typecheck</span>
<a name="line-1018"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Text</span>   <span class='hs-comment'>-- ^ Text representation of the result. Contains an error</span>
<a name="line-1019"></a>                   <span class='hs-comment'>--   message on failure.</span>
<a name="line-1020"></a><span class='hs-definition'>showType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>supply</span> <span class='hs-varid'>expr</span> <span class='hs-keyglyph'>=</span>
<a name="line-1021"></a>    <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>runInfer</span> <span class='hs-varid'>supply</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>.</span> <span class='hs-varid'>infer</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>expr</span> <span class='hs-keyword'>of</span>
<a name="line-1022"></a>        <span class='hs-conid'>Left</span> <span class='hs-varid'>err</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"Error inferring type of "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>expr</span> <span class='hs-varop'>&lt;&gt;</span><span class='hs-str'>": "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>err</span>
<a name="line-1023"></a>        <span class='hs-conid'>Right</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>expr</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-str'>" :: "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
</pre></body>
</html>
