<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Main</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Main.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Main.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">hindley-milner</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Main</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Preliminaries</a><ul><li><a href="#g:2">Prettyprinting</a></li><li><a href="#g:3">Names</a></li><li><a href="#g:4">Monotypes</a></li><li><a href="#g:5">Polytypes</a></li><li><a href="#g:6">The environment</a></li><li><a href="#g:7">Substitutions</a></li></ul></li><li><a href="#g:8">Typechecking</a></li><li><a href="#g:9">Inference context</a><ul><li><a href="#g:10">Unification</a></li><li><a href="#g:11">Type inference</a><ul><li><a href="#g:12">The language: typed lambda calculus</a></li><li><a href="#g:13">Some useful definitions</a></li><li><a href="#g:14">Inferring the types of all language constructs</a></li></ul></li></ul></li><li><a href="#g:15">Testing</a><ul><li><a href="#g:16">A small custom Prelude</a></li><li><a href="#g:17">Run it!</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module is an extensively documented walkthrough for typechecking a
 basic functional language using the Hindley-Damas-Milner algorithm.</p><p>It can be used in three different forms:</p><ul><li>The source is written in literate programming style, so you can almost
   read it from top to bottom, minus some few references to later.</li><li>Runnable in GHCi.</li><li>The Haddock output yields a nice overview over the definitions given.
   It's not as good of a read as the source since many of the important
   inter-code comments are not visible.</li></ul></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> <a href="#t:Pretty">Pretty</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:ppr">ppr</a> :: a -&gt; <a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a></li></ul></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Name">Name</a> = <a href="#v:Name">Name</a> <a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:MType">MType</a><ul class="subs"><li>= <a href="#v:TVar">TVar</a> <a href="Main.html#t:Name">Name</a></li><li>| <a href="#v:TFun">TFun</a> <a href="Main.html#t:MType">MType</a> <a href="Main.html#t:MType">MType</a></li><li>| <a href="#v:TConst">TConst</a> <a href="Main.html#t:Name">Name</a></li><li>| <a href="#v:TList">TList</a> <a href="Main.html#t:MType">MType</a></li><li>| <a href="#v:TEither">TEither</a> <a href="Main.html#t:MType">MType</a> <a href="Main.html#t:MType">MType</a></li><li>| <a href="#v:TTuple">TTuple</a> <a href="Main.html#t:MType">MType</a> <a href="Main.html#t:MType">MType</a></li></ul></li><li class="src short"><a href="#v:freeMType">freeMType</a> :: <a href="Main.html#t:MType">MType</a> -&gt; <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Set.html#t:Set">Set</a> <a href="Main.html#t:Name">Name</a></li><li class="src short"><a href="#v:substMType">substMType</a> :: <a href="Main.html#t:Subst">Subst</a> -&gt; <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:MType">MType</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:PType">PType</a> = <a href="#v:Forall">Forall</a> (<a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Set.html#t:Set">Set</a> <a href="Main.html#t:Name">Name</a>) <a href="Main.html#t:MType">MType</a></li><li class="src short"><a href="#v:freePType">freePType</a> :: <a href="Main.html#t:PType">PType</a> -&gt; <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Set.html#t:Set">Set</a> <a href="Main.html#t:Name">Name</a></li><li class="src short"><a href="#v:substPType">substPType</a> :: <a href="Main.html#t:Subst">Subst</a> -&gt; <a href="Main.html#t:PType">PType</a> -&gt; <a href="Main.html#t:PType">PType</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Env">Env</a> = <a href="#v:Env">Env</a> (<a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Map-Lazy.html#t:Map">Map</a> <a href="Main.html#t:Name">Name</a> <a href="Main.html#t:PType">PType</a>)</li><li class="src short"><a href="#v:freeEnv">freeEnv</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Set.html#t:Set">Set</a> <a href="Main.html#t:Name">Name</a></li><li class="src short"><a href="#v:substEnv">substEnv</a> :: <a href="Main.html#t:Subst">Subst</a> -&gt; <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Env">Env</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Subst">Subst</a> = <a href="#v:Subst">Subst</a> (<a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Map-Lazy.html#t:Map">Map</a> <a href="Main.html#t:Name">Name</a> <a href="Main.html#t:MType">MType</a>)</li><li class="src short"><a href="#v:empty">empty</a> :: <a href="Main.html#t:Subst">Subst</a></li><li class="src short"><a href="#v:compose">compose</a> :: <a href="Main.html#t:Subst">Subst</a> -&gt; <a href="Main.html#t:Subst">Subst</a> -&gt; <a href="Main.html#t:Subst">Subst</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Infer">Infer</a> a = <a href="#v:Infer">Infer</a> (<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/mtl-2.2.1/html/Control-Monad-Except.html#t:ExceptT">ExceptT</a> <a href="Main.html#t:InferError">InferError</a> (<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/mtl-2.2.1/html/Control-Monad-State-Lazy.html#t:State">State</a> [<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a>]) a)</li><li class="src short"><span class="keyword">data</span> <a href="#t:InferError">InferError</a><ul class="subs"><li>= <a href="#v:CannotUnify">CannotUnify</a> <a href="Main.html#t:MType">MType</a> <a href="Main.html#t:MType">MType</a></li><li>| <a href="#v:OccursCheckFailed">OccursCheckFailed</a> <a href="Main.html#t:Name">Name</a> <a href="Main.html#t:MType">MType</a></li><li>| <a href="#v:UnknownIdentifier">UnknownIdentifier</a> <a href="Main.html#t:Name">Name</a></li><li>| <a href="#v:OutOfFreshNames">OutOfFreshNames</a></li></ul></li><li class="src short"><a href="#v:runInfer">runInfer</a> :: [<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a>] -&gt; <a href="Main.html#t:Infer">Infer</a> a -&gt; <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Either.html#t:Either">Either</a> <a href="Main.html#t:InferError">InferError</a> a</li><li class="src short"><a href="#v:throw">throw</a> :: <a href="Main.html#t:InferError">InferError</a> -&gt; <a href="Main.html#t:Infer">Infer</a> a</li><li class="src short"><a href="#v:unify">unify</a> :: (<a href="Main.html#t:MType">MType</a>, <a href="Main.html#t:MType">MType</a>) -&gt; <a href="Main.html#t:Infer">Infer</a> <a href="Main.html#t:Subst">Subst</a></li><li class="src short"><a href="#v:bindVariableTo">bindVariableTo</a> :: <a href="Main.html#t:Name">Name</a> -&gt; <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:Infer">Infer</a> <a href="Main.html#t:Subst">Subst</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Exp">Exp</a><ul class="subs"><li>= <a href="#v:ELit">ELit</a> <a href="Main.html#t:Lit">Lit</a></li><li>| <a href="#v:EVar">EVar</a> <a href="Main.html#t:Name">Name</a></li><li>| <a href="#v:EApp">EApp</a> <a href="Main.html#t:Exp">Exp</a> <a href="Main.html#t:Exp">Exp</a></li><li>| <a href="#v:EAbs">EAbs</a> <a href="Main.html#t:Name">Name</a> <a href="Main.html#t:Exp">Exp</a></li><li>| <a href="#v:ELet">ELet</a> <a href="Main.html#t:Name">Name</a> <a href="Main.html#t:Exp">Exp</a> <a href="Main.html#t:Exp">Exp</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Lit">Lit</a><ul class="subs"><li>= <a href="#v:LBool">LBool</a> <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Bool.html#t:Bool">Bool</a></li><li>| <a href="#v:LInteger">LInteger</a> <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Prelude.html#t:Integer">Integer</a></li></ul></li><li class="src short"><a href="#v:fresh">fresh</a> :: <a href="Main.html#t:Infer">Infer</a> <a href="Main.html#t:MType">MType</a></li><li class="src short"><a href="#v:liftFresh">liftFresh</a> :: <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:PType">PType</a></li><li class="src short"><a href="#v:extendEnv">extendEnv</a> :: <a href="Main.html#t:Env">Env</a> -&gt; (<a href="Main.html#t:Name">Name</a>, <a href="Main.html#t:PType">PType</a>) -&gt; <a href="Main.html#t:Env">Env</a></li><li class="src short"><a href="#v:infer">infer</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>)</li><li class="src short"><a href="#v:inferLit">inferLit</a> :: <a href="Main.html#t:Lit">Lit</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>)</li><li class="src short"><a href="#v:inferVar">inferVar</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Name">Name</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>)</li><li class="src short"><a href="#v:lookupEnv">lookupEnv</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Name">Name</a> -&gt; <a href="Main.html#t:Infer">Infer</a> <a href="Main.html#t:PType">PType</a></li><li class="src short"><a href="#v:instantiate">instantiate</a> :: <a href="Main.html#t:PType">PType</a> -&gt; <a href="Main.html#t:Infer">Infer</a> <a href="Main.html#t:MType">MType</a></li><li class="src short"><a href="#v:inferApp">inferApp</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>)</li><li class="src short"><a href="#v:inferAbs">inferAbs</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Name">Name</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>)</li><li class="src short"><a href="#v:inferLet">inferLet</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Name">Name</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>)</li><li class="src short"><a href="#v:generalize">generalize</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:PType">PType</a></li><li class="src short"><a href="#v:prelude">prelude</a> :: <a href="Main.html#t:Env">Env</a></li><li class="src short"><a href="#v:-126--62-">(~&gt;)</a> :: <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:MType">MType</a></li><li class="src short"><a href="#v:defaultSupply">defaultSupply</a> :: [<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a>]</li><li class="src short"><a href="#v:main">main</a> :: <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:lambda">lambda</a> :: [<a href="Main.html#t:Name">Name</a>] -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:apply">apply</a> :: <a href="Main.html#t:Exp">Exp</a> -&gt; [<a href="Main.html#t:Exp">Exp</a>] -&gt; <a href="Main.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:int">int</a> :: <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Main.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:bool">bool</a> :: <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Main.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:showType">showType</a> :: <a href="Main.html#t:Env">Env</a> -&gt; [<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a>] -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a></li></ul></div><div id="interface"><h1 id="g:1">Preliminaries</h1><h2 id="g:2">Prettyprinting</h2><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:Pretty" class="def">Pretty</a> a <span class="keyword">where</span> <a href="src/Main.html#Pretty" class="link">Source</a></p><div class="doc"><p>A prettyprinter class. Similar to <code><a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Text-Show.html#t:Show">Show</a></code>, but with a focus on having
 human-readable output as opposed to being valid Haskell.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:ppr" class="def">ppr</a> :: a -&gt; <a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a> <a href="src/Main.html#ppr" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:Pretty" class="caption collapser" onclick="toggleSection('i:Pretty')">Instances</p><div id="section.i:Pretty" class="show"><table><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:Lit">Lit</a> <a href="src/Main.html#line-596" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:Exp">Exp</a> <a href="src/Main.html#line-561" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:InferError">InferError</a> <a href="src/Main.html#line-392" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:Subst">Subst</a> <a href="src/Main.html#line-300" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:Env">Env</a> <a href="src/Main.html#line-255" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:PType">PType</a> <a href="src/Main.html#line-193" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:MType">MType</a> <a href="src/Main.html#line-104" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:Name">Name</a> <a href="src/Main.html#line-76" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:3">Names</h2><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Name" class="def">Name</a> <a href="src/Main.html#Name" class="link">Source</a></p><div class="doc"><p>A <code>name</code> is an identifier in the language we're going to typecheck.
 Variables on both the term and type level have <code><a href="Main.html#t:Name">Name</a></code>s, for example.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Name" class="def">Name</a> <a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Name" class="caption collapser" onclick="toggleSection('i:Name')">Instances</p><div id="section.i:Name" class="show"><table><tr><td class="src"><a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Eq.html#t:Eq">Eq</a> <a href="Main.html#t:Name">Name</a> <a href="src/Main.html#line-71" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Ord.html#t:Ord">Ord</a> <a href="Main.html#t:Name">Name</a> <a href="src/Main.html#line-71" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-String.html#t:IsString">IsString</a> <a href="Main.html#t:Name">Name</a> <a href="src/Main.html#line-73" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:Name">Name</a> <a href="src/Main.html#line-76" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:4">Monotypes</h2><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:MType" class="def">MType</a> <a href="src/Main.html#MType" class="link">Source</a></p><div class="doc"><p>A monotype is an unquantified/unparametric type. Monotypes are the inner
 building blocks of all types. Examples of monotypes are <code>Int</code>, <code>a</code>, <code>a -&gt; b</code>.</p><p>In formal notation, <code><a href="Main.html#t:MType">MType</a></code>s are often called &#964; (tau) types.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:TVar" class="def">TVar</a> <a href="Main.html#t:Name">Name</a></td><td class="doc"><pre>a</pre></td></tr><tr><td class="src"><a name="v:TFun" class="def">TFun</a> <a href="Main.html#t:MType">MType</a> <a href="Main.html#t:MType">MType</a></td><td class="doc"><pre>a -&gt; b</pre></td></tr><tr><td class="src"><a name="v:TConst" class="def">TConst</a> <a href="Main.html#t:Name">Name</a></td><td class="doc"><p><code>Int</code>, <code>()</code>, &#8230;</p></td></tr><tr><td class="src"><a name="v:TList" class="def">TList</a> <a href="Main.html#t:MType">MType</a></td><td class="doc"><pre>[a]</pre></td></tr><tr><td class="src"><a name="v:TEither" class="def">TEither</a> <a href="Main.html#t:MType">MType</a> <a href="Main.html#t:MType">MType</a></td><td class="doc"><pre>Either a b</pre></td></tr><tr><td class="src"><a name="v:TTuple" class="def">TTuple</a> <a href="Main.html#t:MType">MType</a> <a href="Main.html#t:MType">MType</a></td><td class="doc"><pre>(a,b)</pre></td></tr></table></div><div class="subs instances"><p id="control.i:MType" class="caption collapser" onclick="toggleSection('i:MType')">Instances</p><div id="section.i:MType" class="show"><table><tr><td class="src"><a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-String.html#t:IsString">IsString</a> <a href="Main.html#t:MType">MType</a> <a href="src/Main.html#line-123" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:MType">MType</a> <a href="src/Main.html#line-104" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:freeMType" class="def">freeMType</a> :: <a href="Main.html#t:MType">MType</a> -&gt; <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Set.html#t:Set">Set</a> <a href="Main.html#t:Name">Name</a> <a href="src/Main.html#freeMType" class="link">Source</a></p><div class="doc"><p>The free variables of an <code><a href="Main.html#t:MType">MType</a></code>. This is simply the collection of all the
 individual type variables occurring inside of it.</p><p><strong>Example:</strong> The free variables of <code>a -&gt; b</code> are <code>a</code> and <code>b</code>.</p></div></div><div class="top"><p class="src"><a name="v:substMType" class="def">substMType</a> :: <a href="Main.html#t:Subst">Subst</a> -&gt; <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:MType">MType</a> <a href="src/Main.html#substMType" class="link">Source</a></p><div class="doc"><p>Apply a substitution to all known variables contained in an <code><a href="Main.html#t:MType">MType</a></code>.
 Variables not mentioned are left unchanged.</p><p>This operation will not change the <code><a href="Main.html#t:MType">MType</a></code> constructors that may be contained
 inside the <code><a href="Main.html#t:MType">MType</a></code> recursively, it only acts on type variables.</p></div></div><h2 id="g:5">Polytypes</h2><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:PType" class="def">PType</a> <a href="src/Main.html#PType" class="link">Source</a></p><div class="doc"><p>A polytype is a monotype universally quantified over a number of type
 variables. In Haskell, all definitions have polytypes, but since the <code>forall</code>
 is implicit they look a bit like monotypes, maybe confusingly so. For
 example, the type of &quot;1 :: Int&quot; is actually &quot;forall <a href="nothing">nothing</a>. Int&quot;, and
 the type of &quot;id&quot; is &quot;forall a. a -&gt; a&quot;, although GHC displays it as
 &quot;a -&gt; a&quot;.</p><p>A polytype claims to work &quot;for all imaginable type parameters&quot;, very similar
 to how a lambda claims to work &quot;for all imaginable value parameters&quot;. We can
 insert a value into a lambda's parameter to evaluate it to a new value, and
 similarly we'll later insert types into a polytype's quantified variables
 to gain new types.</p><p><strong>Example:</strong> in a definition <code>id :: forall a. a -&gt; a</code>, the <code>a</code> after the
 &#8704; (&quot;forall&quot;) is the collection of type variables, and <code>a -&gt; a</code> is the
 <code><a href="Main.html#t:MType">MType</a></code> quantified over. When we have such an <code>id</code>, we also have its
 specialized version <code>Int -&gt; Int</code> available. This process will be the
 topic of the type inference/unification algorithms.</p><p>In formal notation, <code><a href="Main.html#t:PType">PType</a></code>s are often called &#963; (sigma) types.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Forall" class="def">Forall</a> (<a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Set.html#t:Set">Set</a> <a href="Main.html#t:Name">Name</a>) <a href="Main.html#t:MType">MType</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:PType" class="caption collapser" onclick="toggleSection('i:PType')">Instances</p><div id="section.i:PType" class="show"><table><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:PType">PType</a> <a href="src/Main.html#line-193" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:freePType" class="def">freePType</a> :: <a href="Main.html#t:PType">PType</a> -&gt; <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Set.html#t:Set">Set</a> <a href="Main.html#t:Name">Name</a> <a href="src/Main.html#freePType" class="link">Source</a></p><div class="doc"><p>The free variables of a <code><a href="Main.html#t:PType">PType</a></code> are the free variables of the contained
 <code><a href="Main.html#t:MType">MType</a></code>, except those universally quantified.</p><p><strong>Example:</strong> <code>foo :: forall a. a -&gt; b -&gt; a</code> would be a <code><a href="Main.html#t:PType">PType</a></code> in which
 <code>b</code> is a free type variable, while <code>a</code> is bound (via the <code>forall</code>).</p></div></div><div class="top"><p class="src"><a name="v:substPType" class="def">substPType</a> :: <a href="Main.html#t:Subst">Subst</a> -&gt; <a href="Main.html#t:PType">PType</a> -&gt; <a href="Main.html#t:PType">PType</a> <a href="src/Main.html#substPType" class="link">Source</a></p><div class="doc"><p>Apply a substitution to a <code><a href="Main.html#t:PType">PType</a></code>, replacing all known variables in the
 contained <code><a href="Main.html#t:MType">MType</a></code> except the ones universally quantified.</p><p>Invariant: the quantified variables are not changed by the operation.</p></div></div><h2 id="g:6">The environment</h2><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Env" class="def">Env</a> <a href="src/Main.html#Env" class="link">Source</a></p><div class="doc"><p>The environment consists of all the values available in scope, and their
 associated polytypes.</p><p>Conceptually, the environment also contains all the things you can form by
 combining its elements, but this behaviour is modeled by the inference rules
 and not by the environment itself. This is a good thing, since the
 environment makes infinitely many things available to us: when we have
 <code>z</code>, then we also have <code>y -&gt; z</code> and <code>x y -&gt; z</code> and so on available to us.</p><p>In Haskell terms, the environment consists of all the things you currently
 have available. So if you import the Prelude, your environment consists of</p><pre>id        &#8594;  &#8704;a. a&#8594;a
map       &#8594;  &#8704;a b. (a&#8594;b) &#8594; [a] &#8594; [b]
putStrLn  &#8594;  &#8704;&#8709;. String &#8594; IO ()
&#8230;
</pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Env" class="def">Env</a> (<a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Map-Lazy.html#t:Map">Map</a> <a href="Main.html#t:Name">Name</a> <a href="Main.html#t:PType">PType</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Env" class="caption collapser" onclick="toggleSection('i:Env')">Instances</p><div id="section.i:Env" class="show"><table><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:Env">Env</a> <a href="src/Main.html#line-255" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:freeEnv" class="def">freeEnv</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Set.html#t:Set">Set</a> <a href="Main.html#t:Name">Name</a> <a href="src/Main.html#freeEnv" class="link">Source</a></p><div class="doc"><p>The free variables of an <code><a href="Main.html#t:Env">Env</a></code>ironment are all the free variables of the
 <code><a href="Main.html#t:PType">PType</a></code>s it contains.</p></div></div><div class="top"><p class="src"><a name="v:substEnv" class="def">substEnv</a> :: <a href="Main.html#t:Subst">Subst</a> -&gt; <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Env">Env</a> <a href="src/Main.html#substEnv" class="link">Source</a></p><div class="doc"><p>Performing a <code><a href="Main.html#t:Subst">Subst</a></code>itution in an <code><a href="Main.html#t:Env">Env</a></code>ironment means performing that
 substituion on all the contained <code><a href="Main.html#t:PType">PType</a></code>s.</p></div></div><h2 id="g:7">Substitutions</h2><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Subst" class="def">Subst</a> <a href="src/Main.html#Subst" class="link">Source</a></p><div class="doc"><p>A substitution is a mapping from type variables to <code><a href="Main.html#t:MType">MType</a></code>s. Applying a
 substitution means applying those replacements.</p><p>If you want to unify <code>Int -&gt; Int</code> with <code>a -&gt; a</code>, after inferring that
 <code>a</code> should be <code>Int</code>, that substituion has to be performed on the latter
 value to get rid of all the <code>a</code>s.</p><p>A maybe more intuitive way that will come in handy for <code><a href="Main.html#v:compose">compose</a></code> is to view
 a <code><a href="Main.html#t:Subst">Subst</a></code>itution as a chain of</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Subst" class="def">Subst</a> (<a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/containers-0.5.6.2/Data-Map-Lazy.html#t:Map">Map</a> <a href="Main.html#t:Name">Name</a> <a href="Main.html#t:MType">MType</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Subst" class="caption collapser" onclick="toggleSection('i:Subst')">Instances</p><div id="section.i:Subst" class="show"><table><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:Subst">Subst</a> <a href="src/Main.html#line-300" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:empty" class="def">empty</a> :: <a href="Main.html#t:Subst">Subst</a> <a href="src/Main.html#empty" class="link">Source</a></p><div class="doc"><p>The empty substituion holds nothing, and is the identity of <code><a href="Main.html#v:compose">compose</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:compose" class="def">compose</a> :: <a href="Main.html#t:Subst">Subst</a> -&gt; <a href="Main.html#t:Subst">Subst</a> -&gt; <a href="Main.html#t:Subst">Subst</a> <a href="src/Main.html#compose" class="link">Source</a></p><div class="doc"><p>Combine two substitutions. Applying the resulting substitution means
 applying the right hand side substitution first, and then the left hand
 side.</p><p>In the implementation of <code><a href="Main.html#v:compose">compose</a></code>, we don't apply the substitution to
 anything of course, as we do not yet have anything to apply it to available.
 Because of this, we have to incorporate the first (higher priority)
 substitution substitution into the second one beforehand.</p></div></div><h1 id="g:8">Typechecking</h1><div class="doc"><p>Typechecking does two things:</p><ol><li>If two types are not immediately identical, attempt to <code><a href="Main.html#v:unify">unify</a></code> them
    to get a type compatible with both of them</li><li><code><a href="Main.html#v:infer">infer</a></code> the most general type of a value by comparing the values in its
    definition with the <code><a href="Main.html#t:Env">Env</a></code>ironment</li></ol></div><h1 id="g:9">Inference context</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Infer" class="def">Infer</a> a <a href="src/Main.html#Infer" class="link">Source</a></p><div class="doc"><p>The inference type holds a supply of unique names, and can fail with
 a descriptive error if something goes wrong.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Infer" class="def">Infer</a> (<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/mtl-2.2.1/html/Control-Monad-Except.html#t:ExceptT">ExceptT</a> <a href="Main.html#t:InferError">InferError</a> (<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/mtl-2.2.1/html/Control-Monad-State-Lazy.html#t:State">State</a> [<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a>]) a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Infer" class="caption collapser" onclick="toggleSection('i:Infer')">Instances</p><div id="section.i:Infer" class="show"><table><tr><td class="src"><a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Control-Monad.html#t:Monad">Monad</a> <a href="Main.html#t:Infer">Infer</a> <a href="src/Main.html#line-370" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#t:Functor">Functor</a> <a href="Main.html#t:Infer">Infer</a> <a href="src/Main.html#line-370" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Control-Applicative.html#t:Applicative">Applicative</a> <a href="Main.html#t:Infer">Infer</a> <a href="src/Main.html#line-370" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:InferError" class="def">InferError</a> <a href="src/Main.html#InferError" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:CannotUnify" class="def">CannotUnify</a> <a href="Main.html#t:MType">MType</a> <a href="Main.html#t:MType">MType</a></td><td class="doc"><p>Two types that don't match were attempted to be unified.</p></td></tr><tr><td class="src"><a name="v:OccursCheckFailed" class="def">OccursCheckFailed</a> <a href="Main.html#t:Name">Name</a> <a href="Main.html#t:MType">MType</a></td><td class="doc"><p>A <code><a href="Main.html#v:TVar">TVar</a></code> is bound to an <code><a href="Main.html#t:MType">MType</a></code> that already contains it.</p><p>The canonical example of this is <code>&#955;x. x x</code>, where the first <code>x</code>
 in the body has to have type <code>a &#8594; b</code>, and the second one <code>a</code>. Since
 they're both the same <code>x</code>, this requires unification of <code>a</code> with <code>a &#8594; b</code>,
 which only works if <code>a = a &#8594; b = (a &#8594; b) &#8594; b = &#8230;</code>, yielding an infinite
 type.</p></td></tr><tr><td class="src"><a name="v:UnknownIdentifier" class="def">UnknownIdentifier</a> <a href="Main.html#t:Name">Name</a></td><td class="doc"><p>The value of an unknown identifier was read.</p></td></tr><tr><td class="src"><a name="v:OutOfFreshNames" class="def">OutOfFreshNames</a></td><td class="doc"><p>The supply of <code><a href="Main.html#v:fresh">fresh</a></code> variable names has run out.</p></td></tr></table></div><div class="subs instances"><p id="control.i:InferError" class="caption collapser" onclick="toggleSection('i:InferError')">Instances</p><div id="section.i:InferError" class="show"><table><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:InferError">InferError</a> <a href="src/Main.html#line-392" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:runInfer" class="def">runInfer</a> <a href="src/Main.html#runInfer" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a>]</td><td class="doc"><p>Supply of variable names.</p></td></tr><tr><td class="src">-&gt; <a href="Main.html#t:Infer">Infer</a> a</td><td class="doc"><p>Inference data</p></td></tr><tr><td class="src">-&gt; <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Either.html#t:Either">Either</a> <a href="Main.html#t:InferError">InferError</a> a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Evaluate a value in an <code><a href="Main.html#t:Infer">Infer</a></code>ence context.</p></div></div><div class="top"><p class="src"><a name="v:throw" class="def">throw</a> :: <a href="Main.html#t:InferError">InferError</a> -&gt; <a href="Main.html#t:Infer">Infer</a> a <a href="src/Main.html#throw" class="link">Source</a></p><div class="doc"><p>Throw an <code><a href="Main.html#t:InferError">InferError</a></code> in an <code><a href="Main.html#t:Infer">Infer</a></code>ence context.</p></div></div><h2 id="g:10">Unification</h2><div class="doc"><p>Unification describes the process of making two different types compatible
 by specializing them where needed. A desirable property to have here is
 being able to find the most general unifier. Luckily, we'll be able to do
 that in our type system.</p></div><div class="top"><p class="src"><a name="v:unify" class="def">unify</a> :: (<a href="Main.html#t:MType">MType</a>, <a href="Main.html#t:MType">MType</a>) -&gt; <a href="Main.html#t:Infer">Infer</a> <a href="Main.html#t:Subst">Subst</a> <a href="src/Main.html#unify" class="link">Source</a></p><div class="doc"><p>The unification of two <code><a href="Main.html#t:MType">MType</a></code>s is the most general substituion that can
 be applied to both of them in order to yield the same result.</p><p><strong>Example:</strong> trying to unify <code>a -&gt; b</code> with <code>c -&gt; (Int -&gt; Bool)</code> will result
 in a substitution of <code>a</code> for <code>c</code>, and <code>b</code> for <code>Int -&gt; Bool</code>.</p></div></div><div class="top"><p class="src"><a name="v:bindVariableTo" class="def">bindVariableTo</a> :: <a href="Main.html#t:Name">Name</a> -&gt; <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:Infer">Infer</a> <a href="Main.html#t:Subst">Subst</a> <a href="src/Main.html#bindVariableTo" class="link">Source</a></p><div class="doc"><p>Build a <code><a href="Main.html#t:Subst">Subst</a></code>itution that binds a <code><a href="Main.html#t:Name">Name</a></code> of a <code><a href="Main.html#v:TVar">TVar</a></code> to an <code><a href="Main.html#t:MType">MType</a></code>.
 The resulting substitution should be idempotent, i.e. applying it more than
 once to something should not be any different from applying it only once.</p><ul><li>In the simplest case, this just means building a substitution that just
   does that.</li><li>Substituting a <code><a href="Main.html#t:Name">Name</a></code> with a <code><a href="Main.html#v:TVar">TVar</a></code> with the same name unifies a type
   variable with itself, and the resulting substitution does nothing new.</li><li>If the <code><a href="Main.html#t:Name">Name</a></code> we're trying to bind to an <code><a href="Main.html#t:MType">MType</a></code> already occurs in that
   <code><a href="Main.html#t:MType">MType</a></code>, the resulting substitution would not be idempotent: the <code><a href="Main.html#t:MType">MType</a></code>
   would be replaced again, yielding a different result. This is known as the
   Occurs Check.</li></ul></div></div><h2 id="g:11">Type inference</h2><div class="doc"><p>Type inference is the act of finding out a value's type by looking at the
 environment it is in, in order to make it compatible with it.</p><p>In literature, the Hindley-Damas-Milner inference algorithm (&quot;Algorithm W&quot;)
 is often presented in the style of logical formulas, and below you'll find
 that version along with code that actually does what they say.</p><p>These formulas look a bit like fractions, where the &quot;numerator&quot; is a
 collection of premises, and the denominator is the consequence if all of them
 hold.</p><p><strong>Example:</strong></p><pre>&#915; &#8866; even : Int &#8594; Bool   &#915; &#8866; 1 : Int
-----------------------------------
         &#915; &#8866; even 1 : Bool
</pre><p>means that if we have a value of type <code>Int &#8594; Bool</code> called &quot;even&quot; and a value
 of type <code>Int</code> called <code>1</code>, then we also have a value of type <code>Bool</code> via
 <code>even 1</code> available to us.</p><p>The actual inference rules are polymorphic versions of this example, and
 the code comments will explain each step in detail.</p></div><h3 id="g:12">The language: typed lambda calculus</h3><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Exp" class="def">Exp</a> <a href="src/Main.html#Exp" class="link">Source</a></p><div class="doc"><p>The syntax tree of the language we'd like to typecheck. You can view it
 as a close relative to simply typed lambda calculus, having only the most
 necessary syntax elements.</p><p><strong>Example:</strong> the term <code>let y = &#955;x. f x in z</code> would be represented by</p><pre>ELet &quot;y&quot;
     (EAbs &quot;x&quot;
           (EApp (EVar &quot;f&quot;)
                 (EVar &quot;x&quot;)))
     (EVar z)
</pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ELit" class="def">ELit</a> <a href="Main.html#t:Lit">Lit</a></td><td class="doc"><p>True, 1</p></td></tr><tr><td class="src"><a name="v:EVar" class="def">EVar</a> <a href="Main.html#t:Name">Name</a></td><td class="doc"><pre>x</pre></td></tr><tr><td class="src"><a name="v:EApp" class="def">EApp</a> <a href="Main.html#t:Exp">Exp</a> <a href="Main.html#t:Exp">Exp</a></td><td class="doc"><pre>f x</pre></td></tr><tr><td class="src"><a name="v:EAbs" class="def">EAbs</a> <a href="Main.html#t:Name">Name</a> <a href="Main.html#t:Exp">Exp</a></td><td class="doc"><pre>x -&gt; e</pre></td></tr><tr><td class="src"><a name="v:ELet" class="def">ELet</a> <a href="Main.html#t:Name">Name</a> <a href="Main.html#t:Exp">Exp</a> <a href="Main.html#t:Exp">Exp</a></td><td class="doc"><pre>let x = e in e'</pre></td></tr></table></div><div class="subs instances"><p id="control.i:Exp" class="caption collapser" onclick="toggleSection('i:Exp')">Instances</p><div id="section.i:Exp" class="show"><table><tr><td class="src"><a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-String.html#t:IsString">IsString</a> <a href="Main.html#t:Exp">Exp</a> <a href="src/Main.html#line-604" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:Exp">Exp</a> <a href="src/Main.html#line-561" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Lit" class="def">Lit</a> <a href="src/Main.html#Lit" class="link">Source</a></p><div class="doc"><p>Literals we'd like to support. Since we can't define new data types in our
 simple type system, we'll have to hard-code the possible ones here.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:LBool" class="def">LBool</a> <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Bool.html#t:Bool">Bool</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:LInteger" class="def">LInteger</a> <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Prelude.html#t:Integer">Integer</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Lit" class="caption collapser" onclick="toggleSection('i:Lit')">Instances</p><div id="section.i:Lit" class="show"><table><tr><td class="src"><a href="Main.html#t:Pretty">Pretty</a> <a href="Main.html#t:Lit">Lit</a> <a href="src/Main.html#line-596" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h3 id="g:13">Some useful definitions</h3><div class="top"><p class="src"><a name="v:fresh" class="def">fresh</a> :: <a href="Main.html#t:Infer">Infer</a> <a href="Main.html#t:MType">MType</a> <a href="src/Main.html#fresh" class="link">Source</a></p><div class="doc"><p>Generate a fresh <code><a href="Main.html#t:Name">Name</a></code> in a type <code><a href="Main.html#t:Infer">Infer</a></code>ence context. An example use case
 of this is &#951; expansion, which transforms <code>f</code> into <code>&#955;x. f x</code>, where &quot;x&quot; is a
 new name, i.e. unbound in the current context.</p></div></div><div class="top"><p class="src"><a name="v:liftFresh" class="def">liftFresh</a> :: <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:PType">PType</a> <a href="src/Main.html#liftFresh" class="link">Source</a></p><div class="doc"><p>Lift a <code><a href="Main.html#v:fresh">fresh</a></code>ly generated <code><a href="Main.html#t:MType">MType</a></code> into a <code><a href="Main.html#t:PType">PType</a></code> by quantifying over no
 variables. This is only safe to use if no variable duplication can be
 ensured, as is the case when the argument is <code><a href="Main.html#v:fresh">fresh</a></code>. Violating this rule
 will result in (possibly silent!) name clashes.</p><p><strong>Example:</strong></p><pre>a &#8594; b  &#8658;  &#8704;&#8709; a &#8594; b
</pre></div></div><div class="top"><p class="src"><a name="v:extendEnv" class="def">extendEnv</a> :: <a href="Main.html#t:Env">Env</a> -&gt; (<a href="Main.html#t:Name">Name</a>, <a href="Main.html#t:PType">PType</a>) -&gt; <a href="Main.html#t:Env">Env</a> <a href="src/Main.html#extendEnv" class="link">Source</a></p><div class="doc"><p>Add a new binding to the environment.</p><p>The Haskell equivalent would be defining a new value, for example in module
 scope or in a <code>let</code> block. This corresponds to the &quot;comma&quot; operation used
 in formal notation,</p><pre>&#915;, x:&#963;  &#8801;  extendEnv &#915; (x,&#963;)
</pre></div></div><h3 id="g:14">Inferring the types of all language constructs</h3><div class="top"><p class="src"><a name="v:infer" class="def">infer</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>) <a href="src/Main.html#infer" class="link">Source</a></p><div class="doc"><p>Infer the type of an <code><a href="Main.html#t:Exp">Exp</a></code>ression in an <code><a href="Main.html#t:Env">Env</a></code>ironment, resulting in the
 <code><a href="Main.html#t:Exp">Exp</a></code>s <code><a href="Main.html#t:MType">MType</a></code>along with a substitution that has to be done in order to
 reach this goal.</p><p>This is widely known as <em>Algorithm W</em>.</p></div></div><div class="top"><p class="src"><a name="v:inferLit" class="def">inferLit</a> :: <a href="Main.html#t:Lit">Lit</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>) <a href="src/Main.html#inferLit" class="link">Source</a></p><div class="doc"><p>Literals such as <code><a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Bool.html#v:True">True</a></code> and '1' have their types hard-coded.</p></div></div><div class="top"><p class="src"><a name="v:inferVar" class="def">inferVar</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Name">Name</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>) <a href="src/Main.html#inferVar" class="link">Source</a></p><div class="doc"><p>Inferring the type of a variable is done via</p><pre>x:&#963; &#8712; &#915;   &#964; = instantiate(&#963;)
----------------------------  [Var]
           &#915; &#8866; x:&#964;
</pre><p>which simply means that if <code>x</code> is available in polymorphic form, then we have
 it available in all possible instantiations of that &#963; type. This allows us
 to take a &#963; type, and specialize it to our specific needs.</p></div></div><div class="top"><p class="src"><a name="v:lookupEnv" class="def">lookupEnv</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Name">Name</a> -&gt; <a href="Main.html#t:Infer">Infer</a> <a href="Main.html#t:PType">PType</a> <a href="src/Main.html#lookupEnv" class="link">Source</a></p><div class="doc"><p>Look up the <code><a href="Main.html#t:PType">PType</a></code> of a <code><a href="Main.html#t:Name">Name</a></code> in the <code><a href="Main.html#t:Env">Env</a></code>ironment.</p><p>To give a Haskell analogon, looking up <code>id</code> when <code>Prelude</code> is loaded,
 the resulting <code><a href="Main.html#t:PType">PType</a></code> would be <code>id</code>'s type, namely <code>forall a. a -&gt; a</code>.</p></div></div><div class="top"><p class="src"><a name="v:instantiate" class="def">instantiate</a> :: <a href="Main.html#t:PType">PType</a> -&gt; <a href="Main.html#t:Infer">Infer</a> <a href="Main.html#t:MType">MType</a> <a href="src/Main.html#instantiate" class="link">Source</a></p><div class="doc"><p>Bind all quantified variables of a <code><a href="Main.html#t:PType">PType</a></code> to <code><a href="Main.html#v:fresh">fresh</a></code> type variables.</p><p><strong>Example:</strong> instantiating <code>forall a. a -&gt; b -&gt; a</code> results in the <code><a href="Main.html#t:MType">MType</a></code>
 <code>a -&gt; b -&gt; a</code>, where <code>a</code> is a fresh name (to avoid shadowing issues).</p><p>You can picture the <code><a href="Main.html#t:PType">PType</a></code> to be the prototype converted to an instantiated
 <code><a href="Main.html#t:MType">MType</a></code>, which can now be used in the unification process.</p><p>Another way of looking at it is by simply forgetting which variables were
 quantified over, carefully avoiding name clashes when doing so.</p></div></div><div class="top"><p class="src"><a name="v:inferApp" class="def">inferApp</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>) <a href="src/Main.html#inferApp" class="link">Source</a></p><div class="doc"><p>Function application captures the fact that if we have a function and an
 argument we can give to that function, we also have the result value of the
 result type available to us.</p><pre>&#915; &#8866; f : f&#964;   &#915; &#8866; x : x&#964;   fx&#964; = fresh   unify(f&#964;, x&#964; &#8594; fx&#964;)
-----------------------------------------------------------  [App]
                      &#915; &#8866; f x : fx&#964;
</pre><p>This rule is however a bit backwards to our normal way of thinking about
 typing function application: instead of applying a function to a value
 and investigating the result, we hypothesize the function type <code>x&#964; &#8594; fx&#964;</code>
 of mappting the argument <code>x&#964;</code> to the result type <code>fx&#964;</code>, and make sure this
 mapping unifies with the function <code>f:f&#964;</code> given.</p></div></div><div class="top"><p class="src"><a name="v:inferAbs" class="def">inferAbs</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Name">Name</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>) <a href="src/Main.html#inferAbs" class="link">Source</a></p><div class="doc"><p>Lambda abstraction is based on the fact that when we introduce a new
 variable, the resulting lambda maps from that variable's type to the type
 of the body.</p><pre>&#964; = fresh   &#963; = liftFresh(&#964;)   &#915;, x:&#963; &#8866; e:&#964;'
--------------------------------------------  [Abs]
               &#915; &#8866; &#955;x.e : &#964;&#8594;&#964;'
</pre><p>Here, <code>&#915;, x:&#964;</code> is <code>&#915;</code> extended by one additional mapping, namely <code>x:&#964;</code>.</p><p>Abstraction is typed by extending the environment by a new <code><a href="Main.html#t:MType">MType</a></code>, and if
 under this assumption we can construct a function mapping to a value of
 that type, we can say that the lambda takes a value and maps to it.</p></div></div><div class="top"><p class="src"><a name="v:inferLet" class="def">inferLet</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:Name">Name</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Infer">Infer</a> (<a href="Main.html#t:Subst">Subst</a>, <a href="Main.html#t:MType">MType</a>) <a href="src/Main.html#inferLet" class="link">Source</a></p><div class="doc"><p>A let binding allows extending the environment with new bindings in a
 principled manner. To do this, we first have to typecheck the expression
 to be introduced. The result of this is then generalized to a PType, since
 let bindings introduce new polymorphic values, and then added to the
 environment. Now we can finally typecheck the body of the &quot;in&quot; part of the
 let binding.</p><pre>&#915; &#8866; e:&#964;   &#963; = gen(&#915;,&#964;)   &#915;, x:&#963; &#8866; e':&#964;'
---------------------------------------  [Let]
        &#915; &#8866; let x = e in e' : &#964;'
</pre></div></div><div class="top"><p class="src"><a name="v:generalize" class="def">generalize</a> :: <a href="Main.html#t:Env">Env</a> -&gt; <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:PType">PType</a> <a href="src/Main.html#generalize" class="link">Source</a></p><div class="doc"><p>Generalize an <code><a href="Main.html#t:MType">MType</a></code> to a <code><a href="Main.html#t:PType">PType</a></code> by universally quantifying over
 all the type variables contained in it, except those already mentioned
 in the environment.</p><p><strong>Example:</strong> Generalizing <code>forall a. a -&gt; b -&gt; a</code> yields
 <code>forall a b. a -&gt; b -&gt; a</code>.</p><pre>gen(&#915;,&#964;) = &#8704;{&#945;}. &#963;
    where {&#945;} = free(&#964;) &#8211; free(&#915;)
</pre></div></div><h1 id="g:15">Testing</h1><h2 id="g:16">A small custom Prelude</h2><div class="top"><p class="src"><a name="v:prelude" class="def">prelude</a> :: <a href="Main.html#t:Env">Env</a> <a href="src/Main.html#prelude" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:-126--62-" class="def">(~&gt;)</a> :: <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:MType">MType</a> -&gt; <a href="Main.html#t:MType">MType</a> <span class="fixity">infixr 9</span><span class="rightedge"></span> <a href="src/Main.html#~%3E" class="link">Source</a></p><div class="doc"><p>Synonym for <code><a href="Main.html#v:TFun">TFun</a></code> to make writing type signatures easier.</p><p>Instead of</p><pre>Forall [&quot;a&quot;,&quot;b&quot;] (TFun &quot;a&quot; (TFun &quot;b&quot; &quot;a&quot;))
</pre><p>we can write</p><pre>Forall [&quot;a&quot;,&quot;b&quot;] (&quot;a&quot; ~&gt; &quot;b&quot; ~&gt; &quot;a&quot;)
</pre></div></div><div class="top"><p class="src"><a name="v:defaultSupply" class="def">defaultSupply</a> :: [<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a>] <a href="src/Main.html#defaultSupply" class="link">Source</a></p><div class="doc"><p>Supply to draw fresh type variable names from</p></div></div><h2 id="g:17">Run it!</h2><div class="top"><p class="src"><a name="v:main" class="def">main</a> :: <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/System-IO.html#t:IO">IO</a> () <a href="src/Main.html#main" class="link">Source</a></p><div class="doc"><p>Run type inference on a cuple of values</p></div></div><div class="top"><p class="src"><a name="v:lambda" class="def">lambda</a> :: [<a href="Main.html#t:Name">Name</a>] -&gt; <a href="Main.html#t:Exp">Exp</a> -&gt; <a href="Main.html#t:Exp">Exp</a> <a href="src/Main.html#lambda" class="link">Source</a></p><div class="doc"><p>Build multiple lambda bindings.</p><p>Instead of</p><pre>EAbs &quot;f&quot; (EAbs &quot;x&quot; (EApp &quot;f&quot; &quot;x&quot;))
</pre><p>we can write</p><pre>lambda [&quot;f&quot;, &quot;x&quot;] (EApp &quot;f&quot; &quot;x&quot;)
</pre><p>for</p><pre>&#955;f x. f x
</pre></div></div><div class="top"><p class="src"><a name="v:apply" class="def">apply</a> :: <a href="Main.html#t:Exp">Exp</a> -&gt; [<a href="Main.html#t:Exp">Exp</a>] -&gt; <a href="Main.html#t:Exp">Exp</a> <a href="src/Main.html#apply" class="link">Source</a></p><div class="doc"><p>Apply a function to multiple arguments.</p><p>Instead of</p><pre>EApp (EApp (EApp &quot;f&quot; &quot;x&quot;) &quot;y&quot;) &quot;z&quot;)
</pre><p>we can write</p><pre>apply &quot;f&quot; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
</pre><p>for</p><pre>f x y z
</pre></div></div><div class="top"><p class="src"><a name="v:int" class="def">int</a> :: <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Main.html#t:Exp">Exp</a> <a href="src/Main.html#int" class="link">Source</a></p><div class="doc"><p>Construct an integer literal.</p></div></div><div class="top"><p class="src"><a name="v:bool" class="def">bool</a> :: <a href="file:///home/main/Programs/haskell/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Main.html#t:Exp">Exp</a> <a href="src/Main.html#bool" class="link">Source</a></p><div class="doc"><p>Construct a boolean literal.</p></div></div><div class="top"><p class="src"><a name="v:showType" class="def">showType</a> <a href="src/Main.html#showType" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Main.html#t:Env">Env</a></td><td class="doc"><p>Starting environment, e.g. <code><a href="Main.html#v:prelude">prelude</a></code>.</p></td></tr><tr><td class="src">-&gt; [<a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a>]</td><td class="doc"><p>Fresh variable name supply. Should be non-empty.</p></td></tr><tr><td class="src">-&gt; <a href="Main.html#t:Exp">Exp</a></td><td class="doc"><p>Expression to typecheck</p></td></tr><tr><td class="src">-&gt; <a href="file:///home/main/Coding/haskell/articles/hindley-milner/.cabal-sandbox/share/doc/x86_64-linux-ghc-7.10.1/text-1.2.1.1/html/Data-Text.html#t:Text">Text</a></td><td class="doc"><p>Text representation of the result. Contains an error
   message on failure.</p></td></tr></table></div><div class="doc"><p>Convenience function to run type inference algorithm</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.0</p></div></body></html>